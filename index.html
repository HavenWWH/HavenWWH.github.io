<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="L6Lm9d5Crl"/>
  
  
  
  
  <title>Haven的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Haven的博客">
<meta property="og:url" content="https://havenwwh.github.io/index.html">
<meta property="og:site_name" content="Haven的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Haven">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>

        <a href="/" class="profilepic">
            
            <img lazy-src="/img/avatar.png" class="js-avatar">
            
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Haven</a></h1>
        </hgroup>
        
        
            <form>
                <input type="text" class="st-default-search-input search" id="local-search-input" placeholder="搜索一下" autocomplete="off">
            </form>
            <div id="local-search-result"></div>
        
        
            <script type="text/javascript">
                (function() {
                    'use strict';
                    function getMatchData(keyword, data) {
                        var matchData = [];
                        for(var i =0;i<data.length;i++){
                            if(data[i].title.toLowerCase().indexOf(keyword)>=0) 
                                matchData.push(data[i])
                        }
                        return matchData;
                    }
                    var $input = $('#local-search-input');
                    var $resultContent = $('#local-search-result');
                    $input.keyup(function(){
                        $.ajax({
                            url: '/search.json',
                            dataType: "json",
                            success: function( json ) {
                                var str='<ul class=\"search-result-list\">';                
                                var keyword = $input.val().trim().toLowerCase();
                                $resultContent.innerHTML = "";
                                if ($input.val().trim().length <= 0) {
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                }
                                var results = getMatchData(keyword, json);
                                if(results.length === 0){
                                    $resultContent.empty();
                                    $('#switch-area').show();
                                    return;
                                } 
                                for(var i =0; i<results.length; i++){
                                    str += "<li><a href='"+ results[i].url +"' class='search-result-title'>"+ results[i].title +"</a></li>";
                                }
                                str += "</ul>";
                                $resultContent.empty();
                                $resultContent.append(str);
                                $('#switch-area').hide();
                            }
                        });
                    });
                })();
            </script>
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        
        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a  href="/archives/">主页</a></li>
                        
                            <li><a  href="/archives/">所有文章</a></li>
                        
                            <li><a  href="/tags">标签</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl github"  target="_blank" href="https://github.com/HavenWWH" title="github">github</a>
                            
                        </ul>
                    </nav>
                </section>
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/Block/" style="font-size: 11.43px;">Block</a> <a href="/tags/Category/" style="font-size: 10px;">Category</a> <a href="/tags/Deadlock/" style="font-size: 10px;">Deadlock</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/Https/" style="font-size: 10px;">Https</a> <a href="/tags/KVC/" style="font-size: 10px;">KVC</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/O-n/" style="font-size: 10px;">O(n)</a> <a href="/tags/Rumtime/" style="font-size: 10px;">Rumtime</a> <a href="/tags/RunLoop/" style="font-size: 10px;">RunLoop</a> <a href="/tags/Runtime/" style="font-size: 15.71px;">Runtime</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/git/" style="font-size: 11.43px;">git</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%83%8F%E7%B4%A0/" style="font-size: 10px;">像素</a> <a href="/tags/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/" style="font-size: 10px;">内联函数</a> <a href="/tags/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8/" style="font-size: 10px;">函数的调用</a> <a href="/tags/%E5%88%86%E7%B1%BB/" style="font-size: 10px;">分类</a> <a href="/tags/%E5%8A%9F%E8%83%BD%E7%82%B9/" style="font-size: 11.43px;">功能点</a> <a href="/tags/%E5%8D%8F%E8%AE%AE/" style="font-size: 17.14px;">协议</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 18.57px;">原理</a> <a href="/tags/%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">命令</a> <a href="/tags/%E5%93%8D%E5%BA%94%E9%93%BE/" style="font-size: 10px;">响应链</a> <a href="/tags/%E5%9B%BE%E7%89%87/" style="font-size: 12.86px;">图片</a> <a href="/tags/%E5%9F%BA%E7%A1%80/" style="font-size: 12.86px;">基础</a> <a href="/tags/%E5%B8%B8%E8%AF%86/" style="font-size: 10px;">常识</a> <a href="/tags/%E5%BA%95%E5%B1%82/" style="font-size: 10px;">底层</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/" style="font-size: 10px;">循环引用</a> <a href="/tags/%E6%8E%A8%E9%80%81/" style="font-size: 10px;">推送</a> <a href="/tags/%E6%8F%92%E4%BB%B6%E9%AA%8C%E8%AF%81/" style="font-size: 10px;">插件验证</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/" style="font-size: 11.43px;">日常踩坑</a> <a href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/" style="font-size: 10px;">时间复杂度</a> <a href="/tags/%E6%9C%AC%E5%9C%B0%E5%8C%96%E5%AD%98%E5%82%A8/" style="font-size: 10px;">本地化存储</a> <a href="/tags/%E6%A1%86%E6%9E%B6/" style="font-size: 10px;">框架</a> <a href="/tags/%E6%B6%88%E6%81%AF/" style="font-size: 14.29px;">消息</a> <a href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" style="font-size: 10px;">生命周期</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" style="font-size: 20px;">知识点</a> <a href="/tags/%E7%A7%81%E6%9C%89%E5%BA%93/" style="font-size: 11.43px;">私有库</a> <a href="/tags/%E7%AD%BE%E5%90%8D%E8%AE%A4%E8%AF%81/" style="font-size: 10px;">签名认证</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11.43px;">算法</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 12.86px;">线程</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" style="font-size: 12.86px;">组件化</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/" style="font-size: 10px;">自动化打包</a> <a href="/tags/%E8%AF%81%E4%B9%A6/" style="font-size: 10px;">证书</a> <a href="/tags/%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/" style="font-size: 10px;">资源下载</a> <a href="/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E5%B8%B8/" style="font-size: 10px;">踩坑日常</a> <a href="/tags/%E9%80%82%E9%85%8D/" style="font-size: 11.43px;">适配</a> <a href="/tags/%E9%80%9A%E7%9F%A5/" style="font-size: 10px;">通知</a> <a href="/tags/%E9%93%BE%E6%8E%A5%E8%B7%B3%E8%BD%AC/" style="font-size: 10px;">链接跳转</a> <a href="/tags/%E9%94%81/" style="font-size: 10px;">锁</a>
                    </div>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">爱好很多的程序员</div>
                </section>
                
            </div>
        </div>
    </header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Haven</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/avatar.png" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Haven</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/archives/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags">标签</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="github" target="_blank" href="https://github.com/HavenWWH" title="github">github</a>
                    
                </div>
            </nav>
        </header>
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="post-SDWebImage源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2023/05/02/SDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="article-date">
      <time datetime="2023-05-02T13:30:21.000Z" itemprop="datePublished">2023-05-02</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2023/05/02/SDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">SDWebImage源码解析</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>
<h4 id="SDWebImage结构"><a href="#SDWebImage结构" class="headerlink" title="SDWebImage结构"></a>SDWebImage结构</h4><p><strong>核心类:SDWebImageManager</strong></p>
<ul>
<li>SDWebImageManager内部根据不同的功能分发不同的任务给具体的类实现<ul>
<li>调用SDIWebmageDownLoader进行下载</li>
<li>调用SDWebImageCache进行缓存</li>
<li>调用SDWebImageDecoder进行解码</li>
</ul>
</li>
</ul>
<p><strong>缓存类:SDWebImageCache</strong></p>
<ul>
<li>内存缓存:  NSCache</li>
<li>磁盘缓存: 以文件的形式存在磁盘中</li>
</ul>
<p><strong>下载类:SDIWebmageDownLoader</strong></p>
<ul>
<li>负责管理下载的Session</li>
<li>下载任务逻辑具体由SDWebImageDownLoaderOperation实现, SDWebImageDownLoaderOperation对应一个downloadTask</li>
</ul>
<p>SDWebImageCombinedOperation结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cancelled:  是否取消</span><br><span class="line">downloadToken :每次下载的唯一标识</span><br><span class="line">cacheOperation: 缓存的Operation, 用来设置缓存的类型, 是否需要存储到磁盘, 以及查找缓存</span><br><span class="line">manager(SDIWebmageDownLoader): 下载的类</span><br></pre></td></tr></table></figure>
<p>提供UIImageView+WebCache.h分类加载图片, 最终会调用到以下方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(nullable NSURL *)url</span><br><span class="line">          placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(nullable SDExternalCompletionBlock)completedBlock &#123;</span><br><span class="line">    [self sd_internalSetImageWithURL:url</span><br><span class="line">                    placeholderImage:placeholder</span><br><span class="line">                             options:options</span><br><span class="line">                        operationKey:nil</span><br><span class="line">                       setImageBlock:nil</span><br><span class="line">                            progress:progressBlock</span><br><span class="line">                           completed:completedBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看此方法的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123;</span><br><span class="line">    </span><br><span class="line">    // 取消当前的下载操作 如果不取消，那么当tableView滑动的时候，当前cell的imageView会一直去下载图片，然后优先显示下载完成的图片，直接错乱</span><br><span class="line">    [self sd_cancelCurrentImageLoad];</span><br><span class="line">    </span><br><span class="line">    &#123;......省略一段代码&#125;</span><br><span class="line">    // 判断是否存在</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        &#123;......省略一段代码&#125;</span><br><span class="line">        __weak __typeof(self)wself = self;</span><br><span class="line">        // 关键类 SDWebImageManager 来处理图片下载</span><br><span class="line">        // 下载有三层 1当前manager调用下载  2从缓存中获取，hit失败用SDWebImageDownloader对象调用下载 3.SDWebImageDownloaderOperation最终用继承</span><br><span class="line">        // NSOperation的对象NSURLSession的方法去下载图片，代理里面进行操作</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            [wself removeActivityIndicator];</span><br><span class="line">            if (!wself) return;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                if (!wself) return;</span><br><span class="line">                // 设置了SDWebImageAvoidAutoSetImage 默认不会将UIImage添加进UIImageView对象里面，而放置在conpleteBlock里面交由调用方自己处理，做个滤镜或者淡入淡出什么的</span><br><span class="line">                if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock)</span><br><span class="line">                &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (image) &#123;</span><br><span class="line">                    wself.image = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself.image = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 这里是最终回调出去的block</span><br><span class="line">                if (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        // 保存本次operation,如果发生多次图片请求可以用来取消</span><br><span class="line">        // 先取消当前UIImageView正在下载的任务，然后在保存operations</span><br><span class="line">        // 也就是说当动态绑定的字典里面的key value对应一个图片下载 单个图片value数组就是0，不然就是多个，下载完就会根据key移除</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self removeActivityIndicator];</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码看, 图片下载最终都是由SDWebImageManager进行管理<br><strong>SDImageCache</strong><br>首先进行缓冲存查找</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 从imageCache中寻找图片</span><br><span class="line">//每次向SDWebImageCache索取图片的时候，会先根据图片URL对应的key值先检查内存中是否有对应的图片，如果有则直接返回；如果没有则在ioQueue中去硬盘中查找，其中文件名是是根据URL生成的MD5值，找到之后先将图片缓存在内存中，然后在把图片返回：</span><br><span class="line">- (NSOperation *)queryDiskCacheForKey:(NSString *)key done:(SDWebImageQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    if (!doneBlock) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        doneBlock(nil, SDImageCacheTypeNone);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // First check the in-memory cache...</span><br><span class="line">    // 1.先去内存层面查找</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果在内存没找到</span><br><span class="line">    // 2. 如果内存中没有，则在磁盘中查找。如果找到，则将其放到内存缓存，并调用doneBlock回调</span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建自动释放池，内存即时释放</span><br><span class="line">        //        如果你的应用程序或者线程是要长期运行的并且有可能产生大量autoreleased对象, 你应该使用autorelease pool blocks</span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            // 从硬盘拿，拿到了根据字段存入内存</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            if (diskImage &amp;&amp; self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                // 像素</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                // 缓存到NSCache中</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里开了异步串行队列去Disk中查找，保证不阻塞主线程，而且开了autoreleasepool以降低内存暴涨问题，能得到及时释放，如果能取到，首先缓存到内存中然后再回调<br>如果内存和磁盘中都取不到图片，就会让Manager的另一个手下SDWebImageDownloader去下载图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</span><br><span class="line">options:(SDWebImageOptions)options</span><br><span class="line">progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</span><br><span class="line">    &#123;......&#125;</span><br><span class="line">    // 根据URL生成对应的key  没有特殊处理为[self absoluteString]</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    </span><br><span class="line">    // 前面的操作。主要作了如下处理：</span><br><span class="line">    // 1. 判断url的合法性</span><br><span class="line">    // 2. 创建SDWebImageCombinedOperation对象</span><br><span class="line">    // 3. 查看url是否是之前下载失败过的</span><br><span class="line">    // 去imageCache中寻找图片</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果图片没有找到 或者是SDWebImageRefreshCached 就从网络上下载图片</span><br><span class="line">        </span><br><span class="line">        if ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            if (image &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    // 如果图片存在cache中，但是options还是SDWebImageRefreshCached 通知cache去重新刷新缓存图片</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // 设置下载选项属性</span><br><span class="line">            &#123;......&#125;</span><br><span class="line">            // 开启下载</span><br><span class="line">            // 这里的两个回调都是从DownloaderOperation里面出来的，progressBlock是不要取到的，直接在最外层调用的地方处理，完成的话需要进行cache，因此要在这里处理回调，处理完再回调出去</span><br><span class="line">            id &lt;SDWebImageOperation&gt; subOperation = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">                // 上面的是weak的这里设置成strong 避免被释放掉了</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                </span><br><span class="line">                if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125;</span><br><span class="line">                else if (error) &#123;</span><br><span class="line">                    // 如果出错，则调用完成回调，并将url放入下载挫败url数组中</span><br><span class="line">                    dispatch_main_sync_safe(^&#123;</span><br><span class="line">                        if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                            completedBlock(nil, error, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    </span><br><span class="line">                    if (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotConnectToHost) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    // 当重新下载的时候能获取到了，那么久把他从之前的failURL里面移除</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 是否硬盘缓存</span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line">                    </span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; image &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                        // Image refresh hit the NSURLCache cache, do not call the completion block</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        </span><br><span class="line">                        // 在全局队列中并行处理图片的缓存</span><br><span class="line">                        // 首先对图片做个转换操作，该操作是代理对象实现的</span><br><span class="line">                        // 然后对图片做缓存处理</span><br><span class="line">                        </span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line">                            </span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                // 二级缓存起来</span><br><span class="line">                                [self.imageCache storeImage:transformedImage recalculateFromImage:imageWasTransformed imageData:(imageWasTransformed ? nil : data) forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                                    completedBlock(transformedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        // 下载完成后之后 先cache起来 内存缓存和磁盘缓存都要考虑</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage recalculateFromImage:NO imageData:data forKey:key toDisk:cacheOnDisk];</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        dispatch_main_sync_safe(^&#123;</span><br><span class="line">                            if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                                completedBlock(downloadedImage, nil, SDImageCacheTypeNone, finished, url);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                // 完成之后也要移除掉</span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    @synchronized (self.runningOperations) &#123;</span><br><span class="line">                        if (strongOperation) &#123;</span><br><span class="line">                            [self.runningOperations removeObject:strongOperation];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            operation.cancelBlock = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line">                </span><br><span class="line">                @synchronized (self.runningOperations) &#123;</span><br><span class="line">                    __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                    if (strongOperation) &#123;</span><br><span class="line">                        [self.runningOperations removeObject:strongOperation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (image) &#123;</span><br><span class="line">            // 如果图片存在 直接返回</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (strongOperation &amp;&amp; !strongOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(image, nil, cacheType, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 如果没有cacahe 而且没实现代理下载，直接返回nil</span><br><span class="line">            // Image not in cache and download disallowed by delegate</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (strongOperation &amp;&amp; !weakOperation.isCancelled) &#123;</span><br><span class="line">                    completedBlock(nil, nil, SDImageCacheTypeNone, YES, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            // 移除</span><br><span class="line">            @synchronized (self.runningOperations) &#123;</span><br><span class="line">                [self.runningOperations removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SDWebImageDownloader</strong><br>专门管理下载操作的类, 通过此类进行下载操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __block SDWebImageDownloaderOperation *operation;</span><br><span class="line">    __weak __typeof(self)wself = self;</span><br><span class="line">    </span><br><span class="line">    // 290行，同一个方法里面，进行urlCallBacks的组装</span><br><span class="line">    // 该方法有点明白了，就是让同一个url值生成一个createCallBack --&gt;也就是只出来一个operation任务</span><br><span class="line">    // wself.downloadQueue同一url只会加入一次，但是多次重复请求，urlcallbacks的url数组里面会有多个回调block，这个不影响，只要正真下载一次就好了，回调可以遍历，下面下载完都一直在遍历，没错，这就对了</span><br><span class="line">    [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^&#123;</span><br><span class="line">        NSTimeInterval timeoutInterval = wself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line">        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line">        // 防止NSURLCache 和 SDImageCache重复缓存 如果没有明确告知需要缓存，则禁用图片请求的缓存操作</span><br><span class="line">        // 1. 创建请求对象，并根据options参数设置其属性</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData) timeoutInterval:timeoutInterval];</span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = YES;</span><br><span class="line">        // 设置http头部</span><br><span class="line">        if (wself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = wself.headersFilter(url, [wself.HTTPHeaders copy]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            request.allHTTPHeaderFields = wself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line">        //SDWebImageDownloaderOperation派生自NSOperation，负责图片下载工作</span><br><span class="line">        // 2. 创建SDWebImageDownloaderOperation操作对象，并进行配置</span><br><span class="line">        // SDWebImageDownloaderOperation class</span><br><span class="line">        operation = [[wself.operationClass alloc] initWithRequest:request</span><br><span class="line">                                                        inSession:self.session</span><br><span class="line">                                                          options:options</span><br><span class="line">                                                         progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;</span><br><span class="line">            SDWebImageDownloader *sself = wself;</span><br><span class="line">            if (!sself) return;</span><br><span class="line">            __block NSArray *callbacksForURL;</span><br><span class="line">            // 3. 从管理器的callbacksForURL中找出该URL所有的进度处理回调并调用</span><br><span class="line">            // 这个barrierQueue是并发的，如果是get main queue的话就死锁了</span><br><span class="line">            // 我个人感觉去掉直接写也问题不大，不知道为什么这么写？？？反正是顺序执行</span><br><span class="line">            dispatch_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                // URLCallbacks是mutale字典对象</span><br><span class="line">                callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">            &#125;);</span><br><span class="line">            // 进度正常，肯定有多个block</span><br><span class="line">            for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    SDWebImageDownloaderProgressBlock callback = callbacks[kProgressCallbackKey];</span><br><span class="line">                    // 正在下载的时候回传已经收到的size和totalsize出去</span><br><span class="line">                    if (callback) callback(receivedSize, expectedSize);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                     // 下载完之后会进到这个回调，然后我们用之前存起来的回调再回调出去</span><br><span class="line">                                                        completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;</span><br><span class="line">            SDWebImageDownloader *sself = wself;</span><br><span class="line">            if (!sself) return;</span><br><span class="line">            __block NSArray *callbacksForURL;</span><br><span class="line">            // 4. 从管理器的callbacksForURL中找出该URL所有的完成处理回调并调用，</span><br><span class="line">            // 如果finished为YES，则将该url对应的回调信息从URLCallbacks中删除</span><br><span class="line">            // 个人理解阻塞当前线程，而且barrierQueue也阻塞 那么当同一个URL完成的时候直接没了对象，重复下载也没用了</span><br><span class="line">            dispatch_barrier_sync(sself.barrierQueue, ^&#123;</span><br><span class="line">                callbacksForURL = [sself.URLCallbacks[url] copy];</span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            // 这里一般只有一个，但是多次重复请求</span><br><span class="line">            for (NSDictionary *callbacks in callbacksForURL) &#123;</span><br><span class="line">                SDWebImageDownloaderCompletedBlock callback = callbacks[kCompletedCallbackKey];</span><br><span class="line">                if (callback) callback(image, data, error, finished);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                                                        cancelled:^&#123;</span><br><span class="line">            SDWebImageDownloader *sself = wself;</span><br><span class="line">            // 5. 取消操作将该url对应的回调信息从URLCallbacks中删除</span><br><span class="line">            // 阻塞barrierqueue</span><br><span class="line">            if (!sself) return;</span><br><span class="line">            dispatch_barrier_async(sself.barrierQueue, ^&#123;</span><br><span class="line">                [sself.URLCallbacks removeObjectForKey:url];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        // 是否需要解码</span><br><span class="line">        operation.shouldDecompressImages = wself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        if (wself.urlCredential) &#123;</span><br><span class="line">            operation.credential = wself.urlCredential;</span><br><span class="line">        &#125; else if (wself.username &amp;&amp; wself.password) &#123;</span><br><span class="line">            operation.credential = [NSURLCredential credentialWithUser:wself.username password:wself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // NSOperation Queue 增加一个对象</span><br><span class="line">        //4.设置依赖</span><br><span class="line">        // [operation2 addDependency:operation1];      任务二依赖任务一</span><br><span class="line">        // [operation3 addDependency:operation2];      任务三依赖任务二</span><br><span class="line">        // 6. 将操作加入到操作队列downloadQueue中</span><br><span class="line">        [wself.downloadQueue addOperation:operation];</span><br><span class="line">        // 如果不是FIFO 是 LIFO 队列设置依赖，后进来的成为上面的依赖</span><br><span class="line">        if (wself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&#x27;s dependency</span><br><span class="line">            //FIFO的话正常数组就问题</span><br><span class="line">            // LIFO的话让之前的操作一次依赖最后一次进来的操作就行了</span><br><span class="line">            [wself.lastAddedOperation addDependency:operation];</span><br><span class="line">            wself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过继承NSOperation的SDWebImageDownloaderOperation进来初始化下载任务,创建一个下载的操作<br>通过调用addProgressCallback:completeBlock:forURL:createBlock:来确保同一url只会下载一次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(NSURL *)url createCallback:(SDWebImageNoParamsBlock)createCallback &#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 1. 以dispatch_barrier_sync操作来保证同一时间只有一个线程能对URLCallbacks进行操作</span><br><span class="line">    // 该属性是一个字典，key是图片的URL地址，value则是一个数组，包含每个图片的多组回调信息。由于我们允许多个图片同时下载，因此可能会有多个线程同时操作URLCallbacks属性。为了保证URLCallbacks操作(添加、删除)的线程安全性，SDWebImageDownloader将这些操作作为一个个任务放到barrierQueue队列中，并设置屏障来确保同一时间只有一个线程操作URLCallbacks属性</span><br><span class="line">    // 这个写法阻塞当前线程  而且阻塞barrierQueue队列</span><br><span class="line">    // 这句话表示每个URL下载只会出来一次creatBlock回调出去创建新的任务operation（最终要添加到queue的任务）</span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        BOOL first = NO;</span><br><span class="line">        if (!self.URLCallbacks[url]) &#123;</span><br><span class="line">            // 当第一次进来下载的时候，我们平时外部都是传个completeblock，所以我们的urlcallbacks结构是&#123;&quot;url&quot;:[&#123;&quot;comolete&quot;:&quot;completeBlock&quot;&#125;]&#125;</span><br><span class="line">            // 如果是多次重复下载同一URL图片，结构应该会变成</span><br><span class="line">            // &#123;&quot;url&quot;:[&#123;&quot;comolete&quot;:&quot;completeBlock&quot;&#125;,&#123;&quot;comolete&quot;:&quot;completeBlock&quot;&#125;,&#123;&quot;comolete&quot;:&quot;completeBlock&quot;&#125;,&#123;&quot;comolete&quot;:&quot;completeBlock&quot;&#125;]&#125;</span><br><span class="line">            self.URLCallbacks[url] = [NSMutableArray new];</span><br><span class="line">            first = YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // Handle single download of simultaneous download request for the same URL</span><br><span class="line">        // 2. 处理同一URL的同步下载请求的单个下载</span><br><span class="line">        NSMutableArray *callbacksForURL = self.URLCallbacks[url];</span><br><span class="line">        NSMutableDictionary *callbacks = [NSMutableDictionary new];</span><br><span class="line">        if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];</span><br><span class="line">        if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];</span><br><span class="line">        [callbacksForURL addObject:callbacks];</span><br><span class="line">        self.URLCallbacks[url] = callbacksForURL;</span><br><span class="line">        </span><br><span class="line">        // 如果是第一次，那么回调出去下载</span><br><span class="line">        if (first) &#123;</span><br><span class="line">            createCallback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有下载操作的网络响应序列化处理是放在一个自定义的并行调度队列中来处理的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (SDDispatchQueueSetterSementics,nonatomic)dispatch_queue_t barrierQueue;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func dispatch_barrier_async(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</span><br></pre></td></tr></table></figure>
<p>这个方法重点是你传入的 queue，当你传入的 queue是通过 DISPATCH_QUEUE_CONCURRENT参数自己创建的 queue 时，这个方法会阻塞这个queue（注意是阻塞 queue，而不是阻塞当前线程），一直等到这个 queue中排在它前面的任务都执行完成后才会开始执行自己，自己执行完毕后，再会取消阻塞，使这个 queue中排在它后面的任务继续执行。<br>如果你传入的是其他的 queue,那么它就和 dispatch_async一样了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func dispatch_barrier_sync(_ queue: dispatch_queue_t, _ block: dispatch_block_t):</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个方法的使用和上一个一样，传入自定义的并发队列（DISPATCH_QUEUE_CONCURRENT），它和上一个方法一样的阻塞 queue，不同的是这个方法还会阻塞当前线程。<br>如果你传入的是其他的 queue,那么它就和 dispatch_sync一样了。</p>
<p>** SDWebImageDownloaderOperation **<br>这个类是继承与NSOperation的，并且采用了SDWebImageOperation的代理（只有个cancel的方法）,并且它只暴露了一个方法，initWithRequest:inSession:options:progress:completed:canceled这个初始化方法来配置</p>
<p>由于他是自定义的，那么就必须重写Start的方法，在该方法里面SD已经把NSURLConnection替换成了NSURLSession来进行网络请求的操作，简言之，只要实现NSURLSession的代理方法就能获取到下载数据</p>
<p>这里主要看下一个不断接受data的代理回调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    </span><br><span class="line">    // 这个方法本身就已经是异步了</span><br><span class="line"></span><br><span class="line">    // 1. 附加数据</span><br><span class="line">    </span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line">    </span><br><span class="line">    if ((self.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; self.expectedSize &gt; 0 &amp;&amp; self.completedBlock) &#123;</span><br><span class="line">        // The following code is from http://www.cocoaintheshell.com/2011/05/progressive-images-download-imageio/</span><br><span class="line">        // Thanks to the author @Nyx0uf</span><br><span class="line">        </span><br><span class="line">        // Get the total bytes downloaded</span><br><span class="line">        // 2. 获取已下载数据总大小</span><br><span class="line">        const NSInteger totalSize = self.imageData.length;</span><br><span class="line">        </span><br><span class="line">        // Update the data source, we must pass ALL the data, not just the new bytes</span><br><span class="line">        // 3. 更新数据源，我们需要传入所有数据，而不仅仅是新数据</span><br><span class="line">        CGImageSourceRef imageSource = CGImageSourceCreateWithData((__bridge CFDataRef)self.imageData, NULL);</span><br><span class="line">        </span><br><span class="line">        // 4. 首次获取到数据时，从这些数据中获取图片的长、宽、方向属性值</span><br><span class="line">        if (width + height == 0) &#123;</span><br><span class="line">            CFDictionaryRef properties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, NULL);</span><br><span class="line">            if (properties) &#123;</span><br><span class="line">                NSInteger orientationValue = -1;</span><br><span class="line">                CFTypeRef val = CFDictionaryGetValue(properties, kCGImagePropertyPixelHeight);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;height);</span><br><span class="line">                val = CFDictionaryGetValue(properties, kCGImagePropertyPixelWidth);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberLongType, &amp;width);</span><br><span class="line">                val = CFDictionaryGetValue(properties, kCGImagePropertyOrientation);</span><br><span class="line">                if (val) CFNumberGetValue(val, kCFNumberNSIntegerType, &amp;orientationValue);</span><br><span class="line">                CFRelease(properties);</span><br><span class="line">                </span><br><span class="line">                // When we draw to Core Graphics, we lose orientation information,</span><br><span class="line">                // which means the image below born of initWithCGIImage will be</span><br><span class="line">                // oriented incorrectly sometimes. (Unlike the image born of initWithData</span><br><span class="line">                // in didCompleteWithError.) So save it here and pass it on later.</span><br><span class="line">                // 5. 当绘制到Core Graphics时，我们会丢失方向信息，这意味着有时候由initWithCGIImage创建的图片</span><br><span class="line">                //    的方向会不对，所以在这边我们先保存这个信息并在后面使用。</span><br><span class="line">                orientation = [[self class] orientationFromPropertyValue:(orientationValue == -1 ? 1 : orientationValue)];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        // 6. 图片还未下载完成</span><br><span class="line">        if (width + height &gt; 0 &amp;&amp; totalSize &lt; self.expectedSize) &#123;</span><br><span class="line">            // Create the image</span><br><span class="line">            // 7. 使用现有的数据创建图片对象，如果数据中存有多张图片，则取第一张</span><br><span class="line">            CGImageRef partialImageRef = CGImageSourceCreateImageAtIndex(imageSource, 0, NULL);</span><br><span class="line">            </span><br><span class="line">#ifdef TARGET_OS_IPHONE</span><br><span class="line">            // Workaround for iOS anamorphic image</span><br><span class="line">            // 8. 适用于iOS变形图像的解决方案。我的理解是由于iOS只支持RGB颜色空间，所以在此对下载下来的图片做个颜色空间转换处理。</span><br><span class="line">            if (partialImageRef) &#123;</span><br><span class="line">                const size_t partialHeight = CGImageGetHeight(partialImageRef);</span><br><span class="line">                CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">                CGContextRef bmContext = CGBitmapContextCreate(NULL, width, height, 8, width * 4, colorSpace, kCGBitmapByteOrderDefault | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">                CGColorSpaceRelease(colorSpace);</span><br><span class="line">                if (bmContext) &#123;</span><br><span class="line">                    CGContextDrawImage(bmContext, (CGRect)&#123;.origin.x = 0.0f, .origin.y = 0.0f, .size.width = width, .size.height = partialHeight&#125;, partialImageRef);</span><br><span class="line">                    CGImageRelease(partialImageRef);</span><br><span class="line">                    partialImageRef = CGBitmapContextCreateImage(bmContext);</span><br><span class="line">                    CGContextRelease(bmContext);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    CGImageRelease(partialImageRef);</span><br><span class="line">                    partialImageRef = nil;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">#endif</span><br><span class="line">            </span><br><span class="line">            // 9. 对图片进行缩放、解码操作</span><br><span class="line">            if (partialImageRef) &#123;</span><br><span class="line">                UIImage *image = [UIImage imageWithCGImage:partialImageRef scale:1 orientation:orientation];</span><br><span class="line">                NSString *key = [[SDWebImageManager sharedManager] cacheKeyForURL:self.request.URL];</span><br><span class="line">                UIImage *scaledImage = [self scaledImageForKey:key image:image];</span><br><span class="line">                if (self.shouldDecompressImages) &#123;</span><br><span class="line">                    image = [UIImage decodedImageWithImage:scaledImage];</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    image = scaledImage;</span><br><span class="line">                &#125;</span><br><span class="line">                CGImageRelease(partialImageRef);</span><br><span class="line">                </span><br><span class="line">                dispatch_main_sync_safe(^&#123;</span><br><span class="line">                    if (self.completedBlock) &#123;</span><br><span class="line">                        self.completedBlock(image, nil, nil, NO);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRelease(imageSource);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (self.progressBlock) &#123;</span><br><span class="line">        self.progressBlock(self.imageData.length, self.expectedSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回调到SDWebImageManager存储图片，完成最终回调</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// 内存缓存或者磁盘缓存</span><br><span class="line">- (void)storeImage:(UIImage *)image recalculateFromImage:(BOOL)recalculate imageData:(NSData *)imageData forKey:(NSString *)key toDisk:(BOOL)toDisk &#123;</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 内存缓存有必要的话</span><br><span class="line">    if (self.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        // 1. 内存缓存，将其存入NSCache中，同时传入图片的消耗值</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line">    // 硬盘缓存</span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        // 异步串行队列写入</span><br><span class="line">        // 2. 如果确定需要磁盘缓存，则将缓存操作作为一个任务放入ioQueue中</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            NSData *data = imageData;</span><br><span class="line">            </span><br><span class="line">            if (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line">#if TARGET_OS_IPHONE</span><br><span class="line">                // We need to determine if the image is a PNG or a JPEG</span><br><span class="line">                // PNGs are easier to detect because they have a unique signature (http://www.w3.org/TR/PNG-Structure.html)</span><br><span class="line">                // The first eight bytes of a PNG file always contain the following (decimal) values:</span><br><span class="line">                // 137 80 78 71 13 10 26 10</span><br><span class="line">                </span><br><span class="line">                // If the imageData is nil (i.e. if trying to save a UIImage directly or the image was transformed on download)</span><br><span class="line">                // and the image has an alpha channel, we will consider it PNG to avoid losing the transparency</span><br><span class="line">                int alphaInfo = CGImageGetAlphaInfo(image.CGImage);</span><br><span class="line">                BOOL hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</span><br><span class="line">                                  alphaInfo == kCGImageAlphaNoneSkipFirst ||</span><br><span class="line">                                  alphaInfo == kCGImageAlphaNoneSkipLast);</span><br><span class="line">                // 判断图片格式</span><br><span class="line">                // 3. 需要确定图片是PNG还是JPEG。PNG图片容易检测，因为有一个唯一签名。PNG图像的前8个字节总是包含以下值：137 80 78 71 13 10 26 10</span><br><span class="line">                // 在imageData为nil的情况下假定图像为PNG。我们将其当作PNG以避免丢失透明度。而当有图片数据时，我们检测其前缀，确定图片的类型</span><br><span class="line">                BOOL imageIsPng = hasAlpha;</span><br><span class="line">                </span><br><span class="line">                // But if we have an image data, we will look at the preffix</span><br><span class="line">                // 查看imagedata的的前缀是否是png的</span><br><span class="line">                if ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</span><br><span class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                if (imageIsPng) &#123;</span><br><span class="line">                    data = UIImagePNGRepresentation(image);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    data = UIImageJPEGRepresentation(image, (CGFloat)1.0);</span><br><span class="line">                &#125;</span><br><span class="line">#else</span><br><span class="line">                data = [NSBitmapImageRep representationOfImageRepsInArray:image.representations usingType: NSJPEGFileType properties:nil];</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            [self storeImageDataToDisk:data forKey:key];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>SDWebImageCache的清理缓存策略</strong><br>在初始化的时候注册了几个通知</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 收到内存警告，清楚NSCache [self.memCache removeAllObject]</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(clearMemory)</span><br><span class="line">                                             name:UIApplicationDidReceiveMemoryWarningNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line">// 程序关闭时对硬盘文件做一些处理</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(cleanDisk)</span><br><span class="line">                                             name:UIApplicationWillTerminateNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br><span class="line">// 程序进入后台是也对硬盘进行一些读写</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(backgroundCleanDisk)</span><br><span class="line">                                             name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当收到内存警告时，直接调用NSCache的removeAllObject的方法来清理MemeryCache</li>
<li>当程序退出时或进入后台，根据缓存策略来清理磁盘缓存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// 当程序退出或者推到后台的时候，会有缓存策略管理</span><br><span class="line">// 接收到程序进入后台或者程序退出通知</span><br><span class="line">// 调用该方法，然后先遍历所有缓存文件，记录过期的文件，计算缓存总文件大小</span><br><span class="line">// 先删除过期的文件（默认一周）</span><br><span class="line">// 如果设置最大缓存，而且已经缓存的文件大小超过这个预期值，把所有的文件按最后编辑的时间升序，然后一个个删除，当缓存低于临界就break</span><br><span class="line">- (void)cleanDiskWithCompletionBlock:(SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">   dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">       // diskCachePath</span><br><span class="line">       //        /Users/mkjing/Library/Developer/CoreSimulator/Devices/7A62E354-CB88-4012-A119-7B64089B7171/data/Containers/Data/Application/E5275526-CD16-499D-B731-6D68938C04FB/Library/Caches/default/com.hackemist.SDWebImageCache.default</span><br><span class="line">       NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line">       // 需要获取的属性列表 是否文件夹  最后一次编辑时间和文件大小（如有压缩，就是压缩后的）</span><br><span class="line">       NSArray *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">       </span><br><span class="line">       // This enumerator prefetches useful properties for our cache files.</span><br><span class="line">       // 1. 该枚举器预先获取缓存文件的有用的属性 （根据存储的文件夹获取所有文件的枚举器）</span><br><span class="line">       NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                  includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                     options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                errorHandler:NULL];</span><br><span class="line">       </span><br><span class="line">       NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.maxCacheAge];</span><br><span class="line">       NSMutableDictionary *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">       NSUInteger currentCacheSize = 0;</span><br><span class="line">       </span><br><span class="line">       // Enumerate all of the files in the cache directory.  This loop has two purposes:</span><br><span class="line">       //</span><br><span class="line">       //  1. Removing files that are older than the expiration date.</span><br><span class="line">       //  2. Storing file attributes for the size-based cleanup pass.</span><br><span class="line">       // 2. 枚举缓存文件夹中所有文件，该迭代有两个目的：移除比过期日期更老的文件；存储文件属性以备后面执行基于缓存大小的清理操作</span><br><span class="line">       NSMutableArray *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">       for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">           // 根据resourceKeys和路径获取到遍历文件的数据字典</span><br><span class="line">           NSDictionary *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:NULL];</span><br><span class="line">           </span><br><span class="line">           // Skip directories.</span><br><span class="line">           // 3. 跳过文件夹</span><br><span class="line">           if ([resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           // Remove files that are older than the expiration date;</span><br><span class="line">           // 4. 移除早于有效期的老文件 （根据最后一次编辑时间属性来判断）</span><br><span class="line">           NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];// 获取文件编辑时间</span><br><span class="line">           // 返回晚一点的date 如果是experiationDate ，说明该文件是要删除的</span><br><span class="line">           if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">               [urlsToDelete addObject:fileURL];</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           // Store a reference to this file and account for its total size.</span><br><span class="line">           // 5. 存储文件的引用并计算所有文件的总大小，以备后用</span><br><span class="line">           NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">           currentCacheSize += [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">           // 把所有的文件都装进cachefile里面 根据fileURL定位</span><br><span class="line">           [cacheFiles setObject:resourceValues forKey:fileURL];</span><br><span class="line">       &#125;</span><br><span class="line">       // 移除过期的先</span><br><span class="line">       for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">           [_fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // If our remaining disk cache exceeds a configured maximum size, perform a second</span><br><span class="line">       // size-based cleanup pass.  We delete the oldest files first.</span><br><span class="line">       // 6.如果磁盘缓存的大小大于我们配置的最大大小，则执行基于文件大小的清理，我们首先删除最老的文件</span><br><span class="line">       if (self.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.maxCacheSize) &#123;</span><br><span class="line">           // Target half of our maximum cache size for this cleanup pass.</span><br><span class="line">           // 7. 以设置的最大缓存大小的一半作为清理目标</span><br><span class="line">           const NSUInteger desiredCacheSize = self.maxCacheSize / 2;</span><br><span class="line">           </span><br><span class="line">           // Sort the remaining cache files by their last modification time (oldest first).</span><br><span class="line">           // 从小到大排序，也就是最早的时间在最前面 升序// 8. 按照最后修改时间来排序剩下的缓存文件</span><br><span class="line">           NSArray *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                           usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">               return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">           &#125;];</span><br><span class="line">           </span><br><span class="line">           // Delete files until we fall below our desired cache size.</span><br><span class="line">           // 9. 删除文件，直到缓存总大小降到我们期望的大小</span><br><span class="line">           for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">               // 由于之前过期的一部分已经移除了，但是都加进了cacheFile里面，如果不能移除，我们已经过期删除了，直接跳过进行下一个</span><br><span class="line">               // 移除成功，那么计算cacheFile大小</span><br><span class="line">               if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                   NSDictionary *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                   NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                   currentCacheSize -= [totalAllocatedSize unsignedIntegerValue];</span><br><span class="line">                   // 降到期望值以下就可以停了</span><br><span class="line">                   if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (completionBlock) &#123;</span><br><span class="line">           dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               completionBlock();</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h5><ol>
<li>通过UIView+WebCache调用setImageUrl,  setImageUrl内部会调用SDWebImageManager的方法</li>
<li>对于同一个控件, 如果当前的Url已在下载, 则取消在Operation中对应的task(每次下载的task会存在全局的字典中)</li>
<li>设置Placeholder</li>
<li>获取单例SDWebManager, 开始一个图片任务的时候会创建一个对应Operation(SDWebImageCombinedOperation)添加到Operation数组(runningOperations)</li>
<li>由SDWebImageCache进行缓存查找流程(详见缓存查找流程)</li>
<li>缓存中查找到,则runningOperations中移除对应的Operation, 缓存查找不到, 由SDIWebmageDownLoader进入下载流程(详见下载流程)</li>
<li>下载完, 开始解码(详见解码流程)</li>
<li>解码完成存储到缓存</li>
<li>根据options判断是否需要把Image结果回调回去<ul>
<li>如果不需要设置图片就直接把图片返回给当前的View，并标记当前界面需要刷新。这样runloop在下一个周期，就会刷新view显示图片。</li>
<li>如果需要设置这张图片（如加水印之类的处理）则把图片通过block返回给当前方法的调用者，并在调用者处理完成图片之后，再标记刷新。</li>
</ul>
</li>
<li>结束,runningOperations中移除对应的Operation</li>
</ol>
<p><strong>SDWebImageCache查找缓存流程</strong></p>
<ul>
<li>SDWebImage定义了内存缓存对象SDMemoryCache(继承于NSCache)</li>
<li>在内存中查找, 内部是使用SDMemoryCache进行缓存<ul>
<li>在内存中取value,如果被系统释放了,则从我们自己保存的弱引用表中取</li>
<li>弱引用表中取到后, 又往NSCache中存储一份</li>
</ul>
</li>
<li>如果内存没找到, 则创建一个NSOperation进行磁盘查找(耗时,异步执行), 并且这oprearion会保存到 -  - SDWebImageCombinedOperation中</li>
<li>磁盘查到后再缓存到内存中, 回调展示图片</li>
</ul>
<p><strong>SDIWebmageDownLoader下载流程</strong><br>每个Url对应一个sessionTask    </p>
<ul>
<li>每个下载都会封装成一个SDWebImageDownloaderOperation,将这个operation保存到全局的字典中, 并添加到NSOperationQueue下载队列中设置顺序和依赖, 默认并发数6</li>
<li>当下载队列操作Operation时, 会调用对应的Start方法</li>
<li>Start方法方法内部会通过NSURLSession创建dataTask, 并调用resume执行任务</li>
<li>监听session的代理, 并根据NSURLSessionTask的taskIdentifier取出对应Operation, 并将代理分发到对应的Operation中</li>
<li>由每个SDWebImageDownloaderOperation接受和处理自己的数据</li>
<li>下载完成, 将图片数据传递到SDWebImageDecoder 进行解码</li>
<li>解码完成将图片回调给UI进行显示, 并存储图片到内存和磁盘(磁盘存储又是单独创建一个NSOperationQueue进行)</li>
</ul>
<p><strong>SDWebImageDecoder 解码流程</strong></p>
<ul>
<li>解码也是创建NSOperationQueue队列进行解码</li>
<li>根据图片文件头标识判断图片类型</li>
<li>通过CoreGraphic框架生成图像</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-synchronized底层原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2023/02/02/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="article-date">
      <time datetime="2023-02-02T12:10:31.000Z" itemprop="datePublished">2023-02-02</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2023/02/02/synchronized%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">synchronized底层原理</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>iOS中称为同步锁, 也叫对象锁,  底层实质是递归锁, 是对recursive_mutex_t做了封装和处理, 其内部维护了一张表用来存储对象和锁的相关信息，加锁和释放锁的操作就是对锁的计数进行操作</p>
<p>针对一个Person类的run方法进行加锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)run &#123;</span><br><span class="line">    @synchronized (self) &#123;</span><br><span class="line">        NSLog(@&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clang -x objective-c -rewrite-objc Person.m转为C++代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static void _I_Person_run(Person * self, SEL _cmd) &#123;</span><br><span class="line">    &#123; id _rethrow = 0; id _sync_obj = (id)self; objc_sync_enter(_sync_obj);</span><br><span class="line">        try &#123;</span><br><span class="line">            struct _SYNC_EXIT &#123; _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125;</span><br><span class="line">                ~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125;</span><br><span class="line">                id sync_exit;</span><br><span class="line">            &#125; _sync_exit(_sync_obj);</span><br><span class="line">            </span><br><span class="line">            NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1m_kzn6dnx501b1x94s5bwpxjrw0000gn_T_Person_e7a30b_mi_0);</span><br><span class="line">            &#123; id _rethrow = 0; id _sync_obj = (id)self; objc_sync_enter(_sync_obj);</span><br><span class="line">                try &#123;</span><br><span class="line">                    struct _SYNC_EXIT &#123; _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125;</span><br><span class="line">                        ~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125;</span><br><span class="line">                        id sync_exit;</span><br><span class="line">                    &#125; _sync_exit(_sync_obj);</span><br><span class="line">                    </span><br><span class="line">                    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_1m_kzn6dnx501b1x94s5bwpxjrw0000gn_T_Person_e7a30b_mi_1);</span><br><span class="line">                &#125; catch (id e) &#123;_rethrow = e;&#125;</span><br><span class="line">                &#123; struct _FIN &#123; _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">                    ~_FIN() &#123; if (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">                    id rethrow;</span><br><span class="line">                &#125; _fin_force_rethow(_rethrow);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; catch (id e) &#123;_rethrow = e;&#125;</span><br><span class="line">        &#123; struct _FIN &#123; _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">            ~_FIN() &#123; if (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">            id rethrow;</span><br><span class="line">        &#125; _fin_force_rethow(_rethrow);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码看底层最主要就是用objc_sync_enter和objc_sync_exit控制的</p>
<p>objc_sync_enter:加锁的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Allocates recursive mutex associated with &#x27;obj&#x27; if needed.</span><br><span class="line">int objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">        if (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">BREAKPOINT_FUNCTION(</span><br><span class="line">    void objc_sync_nil(void)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>objc_sync_exit解锁的过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// End synchronizing on &#x27;obj&#x27;. </span><br><span class="line">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span><br><span class="line">int objc_sync_exit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        if (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bool okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            if (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SyncData数据结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct alignas(CacheLineSize) SyncData &#123;</span><br><span class="line">    struct SyncData* nextData;</span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;</span><br><span class="line">    int32_t threadCount; </span><br><span class="line">    recursive_mutex_t mutex;</span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure>
<p>SyncData是一个结构体，类似链表</p>
<ul>
<li>struct SyncData* nextData：SyncData的指针节点，指向下一条数据</li>
<li>DisguisedPtr<objc_object> object：锁住的对象</li>
<li>int32_t threadCount：等待的线程数量</li>
<li>recursive_mutex_t mutex：使用的递归锁</li>
</ul>
<p>加锁流程:</p>
<p>tls: Thread Local Storage，线程局部存储，它是操作系统为线程单独提供的私有空间，通常只有有限的容量, 以线程为Key进行存储, 所以他是区分线程的</p>
<ul>
<li>如果支持tls缓存，根据线程从tls缓存中查找对象锁SyncData，找到对lockCount进行+1</li>
<li>如果不支持tls缓存，或者从tls缓存中未找到，就从线程缓存SyncCache总表中查找，同样将对象的锁的次数+1(lockCount+1, threadCount+1)</li>
<li>如果没有缓存命中，就从sDataLists链表中查找，找到之后进行相关的操作，并写入tls缓存和线程缓存SyncCache</li>
<li>都没有找到，说明是第一次进来,则创建一个SyncData，将lockCount= 1, threadCount=1, 并写入缓存tls<br>注意: 整个查找过程是以synchronized(obj)参数obj为key 进行查找的, 是锁的唯一标识用于区分不同的锁, 所以使用锁的时候得保证obj存在</li>
</ul>
<p>解锁流程</p>
<ul>
<li>先从tls缓存中查找，如果找到，对锁的计数减1，更新缓存中的数据，如果当前对象对应的锁计数为0了，直接将其从tls缓存中删除。</li>
<li>从线程缓存SyncCache中查找，如果找到，对锁的计数减1，更新缓存中的数据，如果当前对象对应的锁计数为0了，直接将其从线程缓存SyncCache中删除</li>
<li>从sDataLists查找，找到的话，直接将其置为nil</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-AFNetworking底层原理解析之AFSecurityPolicy" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/12/29/AFNetworking%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8BAFSecurityPolicy/" class="article-date">
      <time datetime="2022-12-29T15:10:31.000Z" itemprop="datePublished">2022-12-29</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/12/29/AFNetworking%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8BAFSecurityPolicy/">AFNetworking底层原理解析之AFSecurityPolicy</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>
<h4 id="AFSecurityPolicy"><a href="#AFSecurityPolicy" class="headerlink" title="AFSecurityPolicy"></a>AFSecurityPolicy</h4><p>HTTPS认证。作为单向认证证书是否合法</p>
<p>AFSecurityPolicy类只做了一件事，就是完成HTTPS认证。作为单向认证证书是否合法。<br> 先来看看HTTP协议，超文本传输协议。目前使用最广泛的HTTP协议版本为1.1。在请求报文中，使用持久连接connection:keep-alive，默认不关闭连接，可以被多个请求复用。使用管道机制，复用一个tcp可以发送多个请求，但同时带来的问题客户端同时发送多个请求之后，服务端的响应只能是依次执行。<br> 在HTTP2.0版本中，首先解决1.1版本中存在的问题，服务端的响应不再依次执行。所有HTTP2.0 通信都在一个TCP连接上完成， 这个连接可以承载任意数量的双向数据流Stream。 相应地， 每个数据流以 消息的形式发送， 而消息由一或多个帧组成， 这些帧可以乱序发送， 然后根据每个帧首部的流标识符重新组装。也就是多工功能。<br> 其次是2.0协议对请求头部内容的压缩。HTTP 1.x每一次通信（请求/响应）都会携带首部信息用于描述资源属性。HTTP 2.0在客户端和服务端之间使用“首部表”来跟踪和存储之前发送的键-值对。首部表在连接过程中始终存在，新增的键-值对会更新到表尾，因此，不需要每次通信都需要再携带首部。<br> 第三，HTTP2.0协议中可以实现服务端自推送功能。服务端可以根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。</p>
<p>HTTPS协议在保证通讯安全的同时，也带来了一些问题：通讯交互处理会变慢，通信时间变长，消耗额外的CPU与内存等资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">    manager.securityPolicy = [self customPolicy];</span><br><span class="line"></span><br><span class="line">-(AFSecurityPolicy *)customPolicy</span><br><span class="line">&#123;</span><br><span class="line">    //加载本地的public.cer证书文件</span><br><span class="line">    NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;public&quot; ofType:@&quot;cer&quot;];</span><br><span class="line">    NSData *cerData = [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line">    NSSet *set = [NSSet setWithObject:cerData];</span><br><span class="line">    //初始化AFSecurityPolicy，导入证书文件</span><br><span class="line">    AFSecurityPolicy *policy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate withPinnedCertificates:set];</span><br><span class="line">    //是否允许使用无效的证书，默认为NO</span><br><span class="line">    policy.allowInvalidCertificates = YES;</span><br><span class="line">    //是否验证证书中的域名domain,可能访问其子域名</span><br><span class="line">    policy.validatesDomainName = NO;</span><br><span class="line">    return policy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过HTTPS协议收到服务端的challenge时，比如需要验证证书，会执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br></pre></td></tr></table></figure>

<p>在AF框架中，遵循挑战处理的代理方法时，自定义了用来如何应对服务器端的不同类型认证挑战。首先判断了接受服务器挑战的方法是否是信任证书，其中只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由自定义Block的实现）。当信任评估通过后，将信任凭证回调给服务器，之后即可进行数据通讯。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF/" rel="tag">消息</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-AFNetworking底层原理解析之序列化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/12/23/AFNetworking%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96/" class="article-date">
      <time datetime="2022-12-23T14:10:31.000Z" itemprop="datePublished">2022-12-23</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/12/23/AFNetworking%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E5%BA%8F%E5%88%97%E5%8C%96/">AFNetworking底层原理解析之序列化</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>
<h4 id="AFURLRequestSerialization"><a href="#AFURLRequestSerialization" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h4><p>请求的序列化<br>查看AFURLRequestSerialization的头文件中，实现了AFURLRequestSerialization协议，协议中只有一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(nullable id)parameters error:(NSError * _Nullable __autoreleasing *)error NS_SWIFT_NOTHROW;</span><br></pre></td></tr></table></figure>
<p>用于返回一个原始request的copy对象，将参数根据指定的编码格式进行处理。<br> AFHTTPRequestSerializer作为请求序列化的一个根类，作为AFN的默认设置。AFJSONRequestSerializer、AFPropertyListRequestSerializer作为子类都继承自AFHTTPRequestSerializer。<br> 头文件中还存在AFMultipartFormData协议，主要用于多部分表单的处理，之后将以表单形式POST请求为例，来分析其中的工作流程。<br> AFURLRequestSerialization协议，继承自&lt;NSObject, NSSecureCoding, NSCopying&gt;三个协议。其中NSSecureCoding协议，主要用于在解码时要同时指定key和要解码的对象的类，如果要求的类和从文件中解码出的对象的类不匹配，NSCoder则会抛出异常并通知数据已经被篡改。NSCopying协议是为了能够让当前类支持拷贝功能。<br> 以POST请求为例，提交的数据都是放到请求体body中，但并未规定编码方式，那么就需要设置Content-Type告知后台服务<br>简单基本的网络请求过程，之前已经介绍过。在实际开发中避免不了与后台大文件传输，那么就要将上传或下载的大文件以数据流的形式进行传输。此时就需要用到AFN框架中的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(id)parameters constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress success:(void (^)(NSURLSessionDataTask *task, id responseObject))success failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure</span><br></pre></td></tr></table></figure>
<p>方法，与AFN中基本的POST方法相比，多声明了一处参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br></pre></td></tr></table></figure>
<p>看看它又多做了什么处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)POST: (NSString *)URLString</span><br><span class="line">parameters: (id)parameters</span><br><span class="line">constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">progress: (nullable void (A) (NSProgress * _Nonnu11))uploadProgress success:(void (A) (NSURLSessionDataTask *task, id responseObject) )success failure:(void (A) (NSURLSessionDataTask *task, NSError *error)) failure</span><br><span class="line">	NSError *serializationError = nil;</span><br><span class="line">	NSMutabLeURLRequest krequest = (self. requestSerializer multipartFormRequestwithMethod:@&quot;POST&quot; URLString:</span><br><span class="line">(INSURL URLWithString:URLString relativeToURL: self .baseURL] absoluteString] parameters:parameters constructingBodywithBlock:block error:&amp;serializationError);</span><br><span class="line">	if (serializationError)</span><br><span class="line">	if (failure) &#123;</span><br><span class="line">#pragma clang diagnostic push #pragma clang diagnostic ignored &quot;-Won&quot;.</span><br><span class="line">		dispatch_async(self.completionQueue ?: dispatch_get_main_queue), ^&#123;</span><br><span class="line">			failure (nil, serializationError);</span><br><span class="line">		&#125;);</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">	&#125;</span><br><span class="line">	return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	__block NSURLSessionDataTask *task - [self uploadTaskWithStreamedRequest: request progress:uploadProgress</span><br><span class="line">completionHandler:^(NSURLResponse</span><br><span class="line">* __unused response, id responseObject, NSError *error) &#123;</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		if(failure) &#123;</span><br><span class="line">			failure(task, error);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if (success) &#123;</span><br><span class="line">				success (task, responseObject);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;];</span><br><span class="line">	[task resume];</span><br><span class="line">	return task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现方法</p>
<p>可以发现，通过声明一个AFMultipartFormData类型的formData来构建用于multipartForm请求体request</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *)multipartFormRequestWithMethod:(NSString *)method</span><br><span class="line">                                              URLString:(NSString *)URLString</span><br><span class="line">                                             parameters:(NSDictionary *)parameters</span><br><span class="line">                              constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                                  error:(NSError *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(method);</span><br><span class="line">    NSParameterAssert(![method isEqualToString:@&quot;GET&quot;] &amp;&amp; ![method isEqualToString:@&quot;HEAD&quot;]);</span><br><span class="line"></span><br><span class="line">    NSMutableURLRequest *mutableRequest = [self requestWithMethod:method URLString:URLString parameters:nil error:error];</span><br><span class="line"></span><br><span class="line">    __block AFStreamingMultipartFormData *formData = [[AFStreamingMultipartFormData alloc] initWithURLRequest:mutableRequest stringEncoding:NSUTF8StringEncoding];</span><br><span class="line"></span><br><span class="line">    if (parameters) &#123;</span><br><span class="line">        for (AFQueryStringPair *pair in AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">            NSData *data = nil;</span><br><span class="line">            if ([pair.value isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">                data = pair.value;</span><br><span class="line">            &#125; else if ([pair.value isEqual:[NSNull null]]) &#123;</span><br><span class="line">                data = [NSData data];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                data = [[pair.value description] dataUsingEncoding:self.stringEncoding];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (data) &#123;</span><br><span class="line">                [formData appendPartWithFormData:data name:[pair.field description]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (block) &#123;</span><br><span class="line">        block(formData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [formData requestByFinalizingMultipartFormData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现方法中，首先用断言判断了GET与HEAD类型的请求不能继续执行后续代码。在创建了mutableRequest之后，为了构建bodyStream，初始化了一个AFStreamingMultipartFormData类型的对象，并用__block修饰。在其init方法中，分别声明了实例变量请求request、字符串编码格式stringEncoding、分隔符boundary以及数据流bodyStream。<br> 这里扩展一下，AFMultipartBodyStream类中声明了NSInputStream类型的对象。而NSInputStream是文件的读取流,是将本地的文件读取到内存中去 ，与之对应的就是NSOutputStream，文件的写入流，将内存中的文件数据写入到文件中。继续深入的话，网络请求都是基于coreFoundation的cfnetwork，而文件的读、写流，也分别对应着coreFoundation中的CFWriteStreamRef与CFWriteStreamRef相关的C函数,CoreFoundation框架中的CFStream头文件<br>AFN中定义的分隔符方法，使用两个十六进制随机数拼接在Boundary后面来表示分隔符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static NSString * AFCreateMultipartFormBoundary() &#123;</span><br><span class="line">    return [NSString stringWithFormat:@&quot;Boundary+%08X%08X&quot;, arc4random(), arc4random()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完成AFStreamingMultipartFormData对象后，接下来的操作与基本POST请求相同，遍历parameters参数字典，将其转换成NSData并拼接进之前的AFStreamingMultipartFormData对象中。<br> 而构造bodyStream最主要的实现，就在[formData appendPartWithFormData:data name:[pair.field description]]这行代码中，根据data和name来构建request的header与body<br>在方法实现中，拼接成符合表单传输的格式，并添加至实例变量bodyStream中，也就是对应的body数据。<br>接下来的，执行block(formData)代码块，就可以在代码实现的block中将图片添加至formData。<br> constructingBodyWithBlock:(void (^)(id <AFMultipartFormData> formData))block添加本地图片实现方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *imgPath = [[NSBundle mainBundle] pathForResource:@&quot;upload&quot; ofType:@&quot;png&quot;];</span><br><span class="line">[formData appendPartWithFileURL:[NSURL fileURLWithPath:imgPath] name:@&quot;(后台指定的key名)&quot; error:nil];</span><br></pre></td></tr></table></figure>
<p>添加图片至body数据流中的实现方法，首先利用文件扩展名和C函数获取UTI统一类型标志符，再根据UTI获取contentType。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static inline NSString * AFContentTypeForPathExtension(NSString *extension) &#123;</span><br><span class="line">    NSString *UTI = (__bridge_transfer NSString *)UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (__bridge CFStringRef)extension, NULL);</span><br><span class="line">    NSString *contentType = (__bridge_transfer NSString *)UTTypeCopyPreferredTagWithClass((__bridge CFStringRef)UTI, kUTTagClassMIMEType);</span><br><span class="line">    if (!contentType) &#123;</span><br><span class="line">        return @&quot;application/octet-stream&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return contentType;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接着，检查fileURL是否合法以及文件是否存在。若文件存在，创建一个AFHTTPBodyPart对象，拼接成符合表单数据结构的字典并放入该对象的header中，完成后将AFHTTPBodyPart对象添加至body数据对象bodyStream。<br>走到这一步，表单中的参数拼接已经完成。但一个完整的表单格式的请求参数，还缺少基本的信息，而保证这些信息的完整性，最后由[formData requestByFinalizingMultipartFormData]方法实现，在表单的首尾添加分隔符、设置request的bodyStream为self.bodyStream（而非setBody方法）、设置Content-Type、设置Content-Length这四步操作。<br>针对表单形式的POST请求，request的初始化已经完成。之后task任务创建与处理，与普通的POST请求无异。<br> AFN框架在表单形式的POST请求中，帮我们做了添加分隔符、并将所有的传参data拼接在一起，作为一个完整的请求数据流发送给服务器等一系列工作<br>这一篇通过举例较为复杂而且经典的表单形式POST请求，可以总结出AFURLRequestSerialization类的作用。<br> 1.使用KVO以及KVC来动态监听并修改request属性<br> 2.设置request的请求header<br> 3.生成请求参数查询字符串<br> 4.支持表单结构数据以数据流拼接分片上传</p>
<hr>
<hr>
<h4 id="AFURLResponseSerialization"><a href="#AFURLResponseSerialization" class="headerlink" title="AFURLResponseSerialization"></a>AFURLResponseSerialization</h4><p>响应的序列化<br>当请求收到返回的数据信息时，这时就要靠AFURLResponseSerialization类来完成不同类型返回数据的序列化操作。<br>从AFURLResponseSerialization头文件中，可以看出与AFURLRequestSerialization类的结构非常相似。从上往下，首先声明了AFURLResponseSerialization协议，协议中只有一个方法，将response解码成指定的相关数据，这是所有响应类都需要遵循的协议。之后声明了一个AFHTTPResponseSerializer类，作为响应类的根类。再往下的类，都是继承自AFHTTPResponseSerializer的子类，分别是AFJSONResponseSerializer（JSON格式数据响应，默认）、AFXMLParserResponseSerializer（iOS端XML数据解析响应）、AFXMLDocumentResponseSerializer（MAC OS端XML数据解析响应）、AFPropertyListResponseSerializer（PList格式数据解析响应）、AFImageResponseSerializer（图片数据解析响应）和AFCompoundResponseSerializer（复合式数据解析响应）<br> 在父类AFHTTPResponseSerializer中，遵循的协议方法不做任何事情 只做一次response的验证。实现方法中，只有[self validateResponse:(NSHTTPURLResponse *)response data:data error:error]验证response是否合规的方法。而且初始化init方法中，父类只是设置编码格式为UTF-8，设置http状态码为200-299，表示只有这些状态码获得了有效的响应，而不在接受范围内的状态码和内容类型会在数据解析时发生错误。而且其中一句代码self.acceptableContentTypes = nil;，本身acceptableContentTypes用于设置可接受的contentType，这里置为nil，也从侧面建议不要直接使用父类。<br>当需要响应具体不同类型的数据序列化操作时，都是由其对应的子类来完成任务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</span><br><span class="line">                    data:(NSData *)data</span><br><span class="line">                   error:(NSError * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    BOOL responseIsValid = YES;</span><br><span class="line">    NSError *validationError = nil;</span><br><span class="line"></span><br><span class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</span><br><span class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</span><br><span class="line"></span><br><span class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</span><br><span class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</span><br><span class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</span><br><span class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                                        &#125; mutableCopy];</span><br><span class="line">                if (data) &#123;</span><br><span class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</span><br><span class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</span><br><span class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</span><br><span class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">                                       &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line">            if (data) &#123;</span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</span><br><span class="line"></span><br><span class="line">            responseIsValid = NO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">        *error = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseIsValid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该验证方法中，默认设置返回BOOL值为YES，后续只处理数据无效的各种情况。首先，根据初始化的acceptableContentTypes 判断MIME媒体类型是否合法；其次，根据初始化的acceptableStatusCodes 判断状态码是否有效。<br> 代码实现中，NSLocalizedDescriptionKey是NSError头文件中预定义的键，标识错误的本地化描述.可以通过NSError的localizedDescription方法获得对应的值信息，而NSURLErrorFailingURLErrorKey相应的值是包含导致加载失败的URL的NSURL。生成错误信息字典，会返回unacceptable content-type的信息，并将错误信息记录在了mutableUserInfo中。<br> 因此，如果content-type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorCannotDecodeContentData；如果MIME type不满足，那么产生的validationError就是Domain为AFURLResponseSerializationErrorDomain，code为NSURLErrorBadServerResponse。<br> 这里需要注意一个error处理逻辑，不管是判断媒体类型还是状态码，都用到了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</span><br></pre></td></tr></table></figure>

<p>查看此函数的实现，可以发现AFN已经处理好了当两种错误同时出现的情况以及优先级显示。将媒体类型的error信息放入至状态码error中userInfo字典的NSUnderlyingErrorKey值中去。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 设置一个underlyingError为error的附属</span><br><span class="line">static NSError * AFErrorWithUnderlyingError(NSError *error, NSError *underlyingError) &#123;</span><br><span class="line">   // 是否传入了error</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        return underlyingError;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否已经有附属</span><br><span class="line">    if (!underlyingError || error.userInfo[NSUnderlyingErrorKey]) &#123;</span><br><span class="line">        return error;</span><br><span class="line">    &#125;</span><br><span class="line">    // 取出error的userInfo</span><br><span class="line">    NSMutableDictionary *mutableUserInfo = [error.userInfo mutableCopy];</span><br><span class="line">    mutableUserInfo[NSUnderlyingErrorKey] = underlyingError;</span><br><span class="line"></span><br><span class="line">    return [[NSError alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以JSON格式的数据为例，当响应到JSON格式的数据时，就需要AFJSONResponseSerializer子类去完成response序列化工作。<br> 首先在初始化方法init中，设置了acceptableContentTypes的集合内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];</span><br></pre></td></tr></table></figure>
<p>（小提示：json格式是 js 代码的一个子集。也就是说 json 格式的数据，也是 js 代码，也会被浏览器的js引擎执行，从而生成 json 对象）<br> 接下来，AFJSONResponseSerializer类遵循的协议方法会对JSON格式的数据进行删除空数据处理，利用遍历与递归将value值为空的key进行删除操作。类似的，AFXMLParserResponseSerializer、AFXMLDocumentResponseSerializer、AFPropertyListResponseSerializer都是将返回数据进行对应格式类型的数据转换，并删除其中无效的key，最终返回出response。AFCompoundResponseSerializer类型的，会进行所有支持数据类型的遍历，以匹配哪种类型的数据可以进行数据解析</p>
<p>这里单独拿出AFImageResponseSerializer类进行分析，此类用于接收处理图片类型的数据。在解析图片数据时，用到了函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static UIImage * AFInflatedImageFromResponseWithDataAtScale(NSHTTPURLResponse *response, NSData *data, CGFloat scale)</span><br></pre></td></tr></table></figure>

<p>来手动解压图片。根据response和scale(scale大小为屏幕宽高)转换为位图bitmap，这里因为解码的过程都是在网络请求回来调用的，避免了系统将在主线程进行解码，从而显示图片的时候直接绘制，节省GPU开销。此函数中主要涉及到了CoreGraphics内容。<br>首先将图片data封装至CGDataProviderRef对象中，然后只针对jpg与png格式的图片数据来单独给CGImageRef对象赋值，以此来创建CGImage用于表示data中的图片是压缩格式。在jpg格式中，AFN单独判断了CMKY类型的图片不支持转换为位图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so fall back to AFImageWithDataAtScale</span><br><span class="line">      if (imageColorSpaceModel == kCGColorSpaceModelCMYK) &#123;</span><br><span class="line">           CGImageRelease(imageRef);</span><br><span class="line">            imageRef = NULL;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>接下来，根据图片data数据创建一个UIImage对象，然后根据上面的CGImageRef对象判断是否为压缩格式图片。若非压缩格式图片且不为空，则直接把原图片返回出去，为空时直接返回nil。接下来就到了处理压缩格式的图片流程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">    size_t width = CGImageGetWidth(imageRef);</span><br><span class="line">    size_t height = CGImageGetHeight(imageRef);</span><br><span class="line">    size_t bitsPerComponent = CGImageGetBitsPerComponent(imageRef);</span><br><span class="line"></span><br><span class="line">    if (width * height &gt; 1024 * 1024 || bitsPerComponent &gt; 8) &#123;</span><br><span class="line">        CGImageRelease(imageRef);</span><br><span class="line"></span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // CGImageGetBytesPerRow() calculates incorrectly in iOS 5.0, so defer to CGBitmapContextCreate</span><br><span class="line">    size_t bytesPerRow = 0;</span><br><span class="line">    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);</span><br><span class="line">    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);</span><br><span class="line"></span><br><span class="line">    if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;</span><br><span class="line">        uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;</span><br><span class="line">        if (alpha == kCGImageAlphaNone) &#123;</span><br><span class="line">            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">            bitmapInfo |= kCGImageAlphaNoneSkipFirst;</span><br><span class="line">        &#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;</span><br><span class="line">            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">            bitmapInfo |= kCGImageAlphaPremultipliedFirst;</span><br><span class="line">        &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CGContextRef context = CGBitmapContextCreate(NULL, width, height, bitsPerComponent, bytesPerRow, colorSpace, bitmapInfo);</span><br><span class="line"></span><br><span class="line">    CGColorSpaceRelease(colorSpace);</span><br><span class="line"></span><br><span class="line">    if (!context) &#123;</span><br><span class="line">        CGImageRelease(imageRef);</span><br><span class="line"></span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CGContextDrawImage(context, CGRectMake(0.0f, 0.0f, width, height), imageRef);</span><br><span class="line">    CGImageRef inflatedImageRef = CGBitmapContextCreateImage(context);</span><br><span class="line"></span><br><span class="line">    CGContextRelease(context);</span><br><span class="line"></span><br><span class="line">    UIImage *inflatedImage = [[UIImage alloc] initWithCGImage:inflatedImageRef scale:scale orientation:image.imageOrientation];</span><br><span class="line"></span><br><span class="line">    CGImageRelease(inflatedImageRef);</span><br><span class="line">    CGImageRelease(imageRef);</span><br><span class="line"></span><br><span class="line">    return inflatedImage;</span><br></pre></td></tr></table></figure>
<p>按照个人理解，首先是通过CoreGraphics框架来获取图片CGImageRef对象的宽高、以及每个颜色的比特数。当宽高像素大于1024*1024像素，或者每个颜色的比特数大于8时，表明图片过大直接返回原图出去。接下来，获取到图片的各种信息，来创建一个CGContextRef类型对象context，也就是bitmap的上下文。继续把context渲染到画布上，根据context生成一个bitmap格式的图片。然后将图片转换成UIImage格式的图片作为response数据返回给AFURLSessionManager类。最终通过block返回出图片数据。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF/" rel="tag">消息</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-AFNetworking底层原理解析之请求流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/12/03/AFNetworking%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/" class="article-date">
      <time datetime="2022-12-03T04:10:31.000Z" itemprop="datePublished">2022-12-03</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/12/03/AFNetworking%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B9%8B%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/">AFNetworking底层原理解析之请求流程</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <span id="more"></span>
<h4 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h4><p><strong>NSURLSession</strong></p>
<ul>
<li>AFURLSessionManager</li>
<li>AFHTTPSessionManager</li>
</ul>
<p><strong>Serialization</strong></p>
<ol>
<li>AFURLRequestSerialization</li>
</ol>
<ul>
<li> AFHTTPRequestSerializer</li>
<li> AFJSONRequestSerializer</li>
<li> AFPropértyListRequestSerializer</li>
</ul>
<ol start="2">
<li>AFURLResponseSerialization</li>
</ol>
<ul>
<li>AFHTTPResponseSerializer</li>
<li>AFJSONResponseSerializer</li>
<li>AXMLParserResponseSerializer</li>
<li>AFXMLDocumentResponseSerializer (macOS)</li>
<li>AFPropertyListResponseSerializer</li>
<li>AFImageResponseSerializer</li>
<li>AFCompoundResponseSerializer</li>
</ul>
<p><strong>AFSecurityPolicy</strong></p>
<p><strong>AFNetworkReachabilityManager</strong></p>
<p>在AFN框架中，负责网络请求通讯最重要的两个类AFURLSessionManager、AFHTTPSessionManager。AFHTTPSessionManager又是继承于AFURLSessionManager，进行了封装。</p>
<p>AFURLRequestSerialization结构的类，主要用于网络请求之前的操作配置，负责配置网络请求的请求头部、序列化请求参数</p>
<p>AFURLResponseSerialization结构的类，主要用于网络请求之后的数据处理，针对不同的数据进行处理，比如JSON、XML、plist、图片格式等数据。</p>
<p>附加功能类中，AFSecurityPolicy主要用于HTTPS环境下的认证安全请求通讯。如果是通过CA认证过的HTTPS访问地址，使用AFN时只需要拼接上https://即可，AFN的网络请求配置中默认使用CA认证访问HTTPS地址；若是自签的证书时，则需要当前类用于进行认证。</p>
<p>AFNetworkReachabilityManager，用于网络状态的监听，判断是否有网络，以及判断网络连接类型，比如蜂窝网络或WiFi环境。但当前类无法判断当前环境能否访问服务器服务。其原理是利用主机的数据包发送。</p>
<hr>
<h4 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h4><p>AFURLSessionManager 这个类是AFN框架的核心类，基本上通过它来实现了大部分核心功能。负责请求的建立、管理、销毁、安全、请求重定向、请求重启等各种功能。他主要实现了NSURLSession和NSRULSessionTask的封装。</p>
<p><strong>AFN网络请求的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+(AFHTTPSessionManager *)httpManager&#123;</span><br><span class="line">    // 获取请求对象</span><br><span class="line">    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class="line">    // 设置请求格式</span><br><span class="line">    manager.requestSerializer = [AFJSONRequestSerializer serializer];</span><br><span class="line">    // 设置返回格式</span><br><span class="line">    manager.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    manager.responseSerializer.acceptableContentTypes = [NSSet setWithObjects:@&quot;text/plain&quot;, @&quot;multipart/form-data&quot;, @&quot;application/json&quot;, @&quot;text/html&quot;, @&quot;image/jpeg&quot;, @&quot;image/png&quot;, @&quot;application/octet-stream&quot;, @&quot;text/json&quot;, nil];</span><br><span class="line">    [manager.requestSerializer setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Accept&quot;];</span><br><span class="line">    [manager.requestSerializer setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</span><br><span class="line">    manager.requestSerializer.timeoutInterval = kRequestTimeOut;</span><br><span class="line">    return manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(__kindof NSURLSessionTask *)Post:(NSString *)URLString parameters:(id)parameters success:(void(^)(id responseObject))success failure:(void(^)(NSError *))failure&#123;</span><br><span class="line">    AFHTTPSessionManager *manager = [self httpManager];</span><br><span class="line">    return [manager POST:URLString parameters:parameters progress:^(NSProgress * _Nonnull uploadProgress) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) &#123;</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            success(responseObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;</span><br><span class="line">        if (failure) &#123;</span><br><span class="line">            failure(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AFN帮我们将繁琐的网络请求进行了封装，只需要传入访问服务器URL以及参数，就可以通过block返回给对应的正确或者错误数据，而且还可以通过progress的block不断获取进度</p>
<p>AFHTTPSessionManager中初始化方法，最终都会指向调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url sessionConfiguration:(NSURLSessionConfiguration *)configuration</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithBaseURL:(NSURL *)url</span><br><span class="line">           sessionConfiguration:(NSURLSessionConfiguration *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    self = [super initWithSessionConfiguration:configuration];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected</span><br><span class="line">    if ([[url path] length] &gt; 0 &amp;&amp; ![[url absoluteString] hasSuffix:@&quot;/&quot;]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:@&quot;&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self.baseURL = url;</span><br><span class="line"></span><br><span class="line">    self.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化时，调用了父类的方法[super initWithSessionConfiguration:configuration]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置默认的configuration，配置session</span><br><span class="line">    if (!configuration) &#123;</span><br><span class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    //当前实例变量持有configuration</span><br><span class="line">    self.sessionConfiguration = configuration;</span><br><span class="line"></span><br><span class="line">    //设置delegate的操作队列并发线程数量为1，即串行队列</span><br><span class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     </span><br><span class="line">     */</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue];</span><br><span class="line">    </span><br><span class="line">    //默认为JSON解析</span><br><span class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    </span><br><span class="line">    //设置默认证书，无条件信任HTTPS认证</span><br><span class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">#if !TARGET_OS_WATCH</span><br><span class="line">    //网络状态监听</span><br><span class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    //存放一个 delegate = value，taskId = key 的字典</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">    //使用NSLock确保线程安全</span><br><span class="line">    self.lock = [[NSLock alloc] init];</span><br><span class="line">    self.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">    //异步获取当前session所有未完成的task。会让后台任务重新回来初始化session，之前可能存在的任务进行置空处理</span><br><span class="line">    //参考AFN问题汇总https://github.com/AFNetworking/AFNetworking/issues/3499</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</span><br><span class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</span><br><span class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</span><br><span class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看出，在AFN初始化过程中，除了对NSURLSession进行初始化之外，还设置了许多默认配置，例如创建串行队列、默认JSON解析、无条件信任证书、保证线程安全、网络状态监听以及旧任务置空处理等操作</p>
<p>以POST请求为例，调用的方法如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString parameters:(nullable id)parameters progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure</span><br></pre></td></tr></table></figure>
<p>进入该方法查看实现，发现除了常用的POST和GET请求之外，还有PUT、HEAD、DELETE、PATCH这些其它请求类型的方法实现，都执行了同一个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method URLString:(NSString *)URLString parameters:(id)parameters uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress success:(void (^)(NSURLSessionDataTask *, id))success failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</span><br></pre></td></tr></table></figure>
<p> 在该方法中，首先调用AFHTTPRequestSerializer的requestWithMethod函数构建request；当有错误时，处理request构建产生的错误 - serializationError；其中relativeToURL表示将URLString拼接至baseURL中。接下来，继续查看requestSerializer的创建方法实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (NSMutableURLRequest *) requestWithMethod: (NSString *)method</span><br><span class="line">URLString:(NSString *)URLString parameters: (id) parameters</span><br><span class="line">error: (NSError * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">	//断言如果为nil，则直接打印出来</span><br><span class="line">	NSParameterAssert (method);</span><br><span class="line">	NSParaneterAssert (URLSYring)</span><br><span class="line">	//传进来的是宇符串，转换成URL</span><br><span class="line">	NSURL *ur] = ENSURL URLWithString:URLString];</span><br><span class="line">	NSParameterAssert (url) ;</span><br><span class="line">	NSMutableURLRequest *mutableRequest = [[NSMutableURLRequest alloc] initwithURL:url];</span><br><span class="line">	//设置请求方式</span><br><span class="line">	mutableRequest .HTTPMethod = method;</span><br><span class="line">	//將request的各种属性进行遍历，给mutableRequest自带的属性赋值</span><br><span class="line">	for (NSString *keyPath in AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">		if(Iself.mutable0bservedChangedkeyPaths containsobject:keyPath]） &#123;</span><br><span class="line">			//通过KVC动态给mutableRequest添加value</span><br><span class="line">			[mutableRequest setValue: [self valueForKeyPath:keyPath] forKey: keyPath];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	//将传入的参数进行编码</span><br><span class="line">	mutableRequest = [Iself requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy』</span><br><span class="line">	return mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>requestSerializer创建方法实现<br>其中最重要的部分，就是将request的各种属性进行遍历，用于给mutableRequest自带的属性赋值。<br>关于AFHTTPRequestSerializerObservedKeyPaths()，查看实现方法可以发现返回一个带有方法名的数组，定义了一个static的方法，表示该方法只能在本文件中使用。利用runtime的反射调用NSStringFromSelector方法，将六个方法名转换成字符串存入数组中。而这个六个方法又分别对应了mutableRequest的六个属性名称 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static NSArray * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">	static NSArray *_AFHTTPRequestSerializerObservedKeyPaths = nil;</span><br><span class="line">	static dispatch_once_t onceToken;</span><br><span class="line">	dispatch_once (&amp;onceToken,^&#123;</span><br><span class="line">		_AFHTTPRequestSerializerObservedKeyPaths =</span><br><span class="line">		@[NSStringFromSelector @selector (allowsCellularAccess)),</span><br><span class="line">			NSStringFromSelector(@selector(cachePolicy)),</span><br><span class="line">			NSStringFromSelector (@selector (HTTPShouldHandleCookies)), </span><br><span class="line">			NSStringFromSelector@selector (HTTPShouldUsePipelining)), </span><br><span class="line">			NSStringFromSelector (@selector (networkServiceType)), NSStringFromSelector (@selector (timeoutInterval))];</span><br><span class="line">	&#125;):</span><br><span class="line">	return _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AFHTTPRequestSerializerObservedKeyPaths()代码实现</p>
<ol>
<li>是否允许使用设备的蜂窝移动网络来创建request，默认为允许;</li>
<li>创建的request所使用的缓存策略，默认使用NSURLRequestUseProtocolCachePolicy，该策略表示如果缓存不存在，直接从服务端获取。如果缓存存在，会根据response中的Cache-Control字段判断下一步操作，如: Cache-Control字段为must-revalidata, 则 询问服务端该数据是否有更新，无更新直接返回给用户缓存数据，若已更新，则请求服务端.</li>
<li>如果设置HTTPShouldHandleCookies为YES，就处理存储在NSHTTPCookieStore中的cookies HTTPShouldHandleCookies表示是否应该给request设置cookie并随request一起发送出去</li>
<li>HTTPShouldUsePipelining表示receiver(理解为iOS客户端)的下一个信息是否必须等到上一个请求回复才能发送。如果为YES表示可以，NO表示必须等receiver收到先前的回复才能发送下个信息</li>
<li>设定request的network service类型. 默认NSURLNetworkServiceTypeDefault. 这个network service是为了告诉系统网络层这个request使用的目的。 比如NSURLNetworkServiceTypeVoIP表示的这个request是用来请求网际协议通话技术(Voice over IP)。系统能根据提供的信息来优化网络处理，从而优化电池寿命，网络性能等等,客户端基本不使用</li>
<li>超时机制，默认60秒</li>
</ol>
<p>至于要在此处实现遍历的目的，是因为在AFHTTPRequestSerializer类的init方法中，AFN给上面指定的6个方法选择器每一个元素添加了KVO观察者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (NsString *keyPath in AFHTTPRequestSerializer0bservedkeyPaths()) &#123;</span><br><span class="line">	if ([self respondsToSelector:NSSelectorFromString(keyPath)]) &#123;</span><br><span class="line">	//自己给自己的方法添加观察者</span><br><span class="line">	[self addObserver:self forkeyPath: keyPath options:NSKeyValueObservingOptionNew</span><br><span class="line">context：AFHTTPRequestSerializerObserverContext]:</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>self为自己的方法添加观察者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)observeValueForKeyPath: (NSString *)keyPath ofObject: ( unused id)object change: (NSDictionary *) change context: (void *) context &#123;</span><br><span class="line">	if (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">		if ([change [NSKeyValueChangeNewKey] isEqual:[NSNull nulljj) &#123;</span><br><span class="line">			[self .mutable0bservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			[self.mutable0bservedChangedKeyPaths addObject: keyPath];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KVO代理实现<br>当数组的元素发生变化时，判断新值是否为空。若为空则从mutableObservedChangedKeyPaths可变集合中移除；不为空，则添加至可变集合中。<br> 小提示：关于NSNull，包含了唯一方法+(NSNull *)null，是一个对象，用于表示零值的单独对象。主要用于不能使用nil的场景下，例如可变数组中，想插入一个空对象的情况。<br> 因此，在AFHTTPSessionManager初始完成之后，需要额外添加自定义的request配置时，比如超时时间设置为10秒。这时KVO监听到timeoutInterval的属性发生变化，将keyPath添加到mutableObservedChangedKeyPaths可变集合中。然后，在执行网络请求方法时，会遍历该可变集合，通过KVC动态的给mutableRequest添加value，最终实现将自定义配置添加至request中。<br> 而且在AFHTTPRequestSerializer类的初始化方法中，AFN自动添加了网络请求头部内容</p>
<p>接下来，到了AFN的重点，对传入的参数字典进行处理。<br> 使用AFN传入的参数格式为字典，但在网络请求中，是要转换成key=value&amp;key=value的形式(GET请求直接拼接到URL之后，POST请求放入request body中)，才能传给服务端获取有效的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//将我们传入的宇典转成字符串</span><br><span class="line">NSString *query = nil;</span><br><span class="line">if (parameters) &#123;</span><br><span class="line">	//自定义的解析方式</span><br><span class="line">	if (self.queryStringSerialization) €</span><br><span class="line">		NSError *serializationError;</span><br><span class="line">		query = self.queryStringSerialization(request, parameters, &amp;serializationError)</span><br><span class="line">		if (serializationError) &#123;</span><br><span class="line">			if (error) &#123;</span><br><span class="line">				*error = serializationError;</span><br><span class="line">			&#125;</span><br><span class="line">			return nil;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		//默认解析方式，宇典一&gt; 宇符串：key=valueakey=value</span><br><span class="line">		switch (self.queryStringSerializationstyle) &#123;</span><br><span class="line">		case AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">			//将parameters传入这个C函数</span><br><span class="line">			query = AFQueryStringFromParameters(parameters);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将请求参数字典转化成字符串<br>NSString * AFQueryStringFromParameters(NSDictionary *parameters)C函数的作用，是遍历数组中的AFQueryStringPair，然后以&amp;符号拼接。AFQueryStringPair是一个数据处理类，只有两个属性:field和value；一个方法：-URLEncodedStringValue。它的作用就是上面我们说的，以key=value的形式，然后用URL Encode编码，拼接成字符串。<br> 在遍历过程中，最终指向了NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value)函数，为了保证参数字典中，所有的value类型确保为字符串类型，这里便使用了递归，针对value可能为字典、数组、集合的类型时进行解析。例如，之前的项目中当需要向后台传输一段用户的定位数据用于分析行动轨迹时，传参的字典中的location的key值嵌套了一个包含分别以经度和纬度为key的字典。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">NSArray * AFQueryStringPairsFromKeyAndValue(NSString *key, id value) (</span><br><span class="line">	NSMutableArray *mutableQueryStringComponents = [NSMutableArray array);</span><br><span class="line">	/*根据需要排列的对款的description来进行开序排列，井且selector使用的是compare:</span><br><span class="line">因为对象的description返回的是NSString.</span><br><span class="line">，所以此处compare： 使用的是NSStzing的compare函数</span><br><span class="line">*/</span><br><span class="line">	NSSortDescriptor *sortDescriptor - (NSSortDescriptor sortDescriptorWithkey:@&quot;description&quot; ascending:YES</span><br><span class="line">selector:@selector (compare:)]:</span><br><span class="line">	//判断vaLue是什么类型的，然后去道归调用自己，直到解析的是除了azray dic set以外的元素，然后把得到的参致数组返回。</span><br><span class="line">	if ([value isKindOfClass:(NSDictionary class])) &#123;</span><br><span class="line">		NSDictionary *dictionary = velue;</span><br><span class="line">		// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span><br><span class="line">		/*</span><br><span class="line">		allkeys: count/start</span><br><span class="line">		*/ </span><br><span class="line">		for (id nestedkey in (dictionary.allkeys sortedArrayUsingDescriptors:el sortDescriptor )]) &#123;</span><br><span class="line">			id nestedValue = dictionary (nestedKey]; //nestedkey=count nestedvalue=5</span><br><span class="line">			if (nestedValue) &#123;</span><br><span class="line">				[mutableQueryStringComponents addobjectsFromArray:AFQueryStringPairsFromKeyAndValue((key</span><br><span class="line">				[NSString stringwithFormat:@&quot;%©[%]&quot;, key, nestedKey] : nestedKey), nestedValue));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	) else if (value isKindofClass: (NSArray class)]) (</span><br><span class="line">		NSArray *array = value;</span><br><span class="line">		for (id nestedValue in array) (</span><br><span class="line">				[mutableQueryStringComponentsaddObjectsFromArray:AFQueryStringPairsFromKeyAndValue((NSString</span><br><span class="line">stringwithformat:0&quot;%@[]&quot;, key), nestedValue)];</span><br><span class="line">		&#125;</span><br><span class="line">	) else if ([value isKindOfClass: (NSSet class])) (</span><br><span class="line">		NSSet *set = value;</span><br><span class="line">		for (id obj in [set sortedArrayUsingDescriptors:@[ sortDescriptor 1]) (</span><br><span class="line">			[mutableQueryStringComponentsaddobjectsFromArray:AFQueryStringPairsFromKeyAndValue(key,obj)];</span><br><span class="line">		)</span><br><span class="line">	) else (//既然是递归，那么就要有结東通归的情况，比如解析到最后，对应va1ue是一个NSString，那么就得调用西数中最后的e1se语句</span><br><span class="line">		//AFQueryStringPair數据处理类，mutableQuezyStringComponents中的元景类型是AFQueryStringPair</span><br><span class="line">		[mutableQueryStringComponents addObject: ((AFQueryStringPair alloc) initwithfield:key value:value]);</span><br><span class="line">	&#125;</span><br><span class="line">	return mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归确保所有的value最终全部转换成字符串形式<br> 当value为字典、数组、集合的类型时，会执行递归解析，直到value类型都不为上述类型时，向mutableQueryStringComponents添加一个AFQueryStringPair类的对象，其中传入key和value并返回出去。<br> （这里AFN框架执行了升序排列，这里不是很明白为什么要先将字典的key进行升序排列再进行数据递归解析）<br> 当传参字典中所有数据解析完成之后，会通过遍历返回为AFQueryStringPair类的对象，然后将该对象进行百分号编码，用于处理可能存在包含歧义或者不符合规划的字符（可以自行查找关于百分号编码相关资料），最后将字符串拼接”&amp;”符号。<br> 以上，就是AFN框架中，发起网络请求之前，关于request处理相关的操作全部流程分析，其中最主要的功能就是对传参参数进行了数据的递归解析，其次对request的六个相关属性进行KVO监听，可以在初始化AFHTTPSessionManager对象之后，自定义修改指定request属性时，通过KVO代理方法以及动态KVC最终在request中实现配置修改</p>
<hr>
<hr>
<p>上面讲到在AFHTTPSessionManager中，在初始化NSMutableURLRequest对象时的流程分析。接下来继续分析在生成request之后AFN创建task任务的流程<br>在NSMutableURLRequest对象初始化之后，创建了一个NSURLSessionDataTask任务类对象，并将request传入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//此时的request已经将参数拼接在ur1后面</span><br><span class="line">__block NSURLSessionDataTask *dataTask -=nil;</span><br><span class="line">dataTask = [self dataTaskwithRequest:request</span><br><span class="line">uploadProgress: uploadProgress downloadProgress: downloadProgress completionHandler: ^ (NSURLResponse * __unused response. id responseObject, NSerror *error) &#123;</span><br><span class="line">	if (error) &#123;</span><br><span class="line">		if (failure) &#123;</span><br><span class="line">			failure (dataTask, error);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (success) &#123;</span><br><span class="line">			success (dataTask, responseObject);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;]：</span><br><span class="line">	return dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建task任务代码</p>
<p>层层代码实现，最终会找到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">delegate.manager = self;</span><br><span class="line">delegate.completionHandler = completionHandler;</span><br><span class="line">dataTask.taskDescription = self.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">[self setDelegate:delegate forTask:dataTask];</span><br><span class="line">//设置回调块</span><br><span class="line">delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">delegate.downloadProgressBlock = downloadProgressBlock;</span><br></pre></td></tr></table></figure>
<p>此处的代码意义为将一个session task和一个AFURLSessionManagerTaskDelegate类型的delegate变量绑在一起，而这个绑在一起的工作是由我们的AFURLSessionManager所做。至于绑定的过程，就是以该session task的taskIdentifier为key（taskIdentifier是在创建task的时候NSURLSessionTask为其设置的，不需要手动设置，保证唯一性），delegate为value。赋值给mutableTaskDelegatesKeyedByTaskIdentifier这个NSMutableDictionary类型的变量，以此来确保task唯一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self setDelegate:delegate forTask:dataTask]</span><br></pre></td></tr></table></figure>
<p>方法就是将两者进行绑定，查看其实现代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    //task和delegate都不能为空</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line"></span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[self.lock lock]与[self.lock unlock]<br>方法用于确保中间代码块为原子操作，保证线程安全。然后将delegate存入字典，以task的id作为key，说明每个task都有各自的代理。<br> 接着，[delegate setupProgressForTask:task]方法设置两个NSProgress的变量 - 上传uploadProgress和下载downloadProgress，给session task添加了监听KVO事件，用于实时监听返回上传、下载progress的更新进度。其内部实现中设置这两个NSProgress对应的cancel、pause和resume这三个状态，正好对应session task的cancel、suspend和resume三个状态。然后给task的当前接收大小、期望接收大小、当前发送大小以及期望发送大小四个属性进行KVO监听，和上传、下载progress的fractionCompleted属性进行KVO监听（fractionCompleted属性代表当前progress已经完成的比例，取值范围0-1）。当task任务的进度发生变化时，KVO则更新对应的progress属性值，然后赋新值触发时会执行KVO代理中上传或者下载progress的处理，将执行对应的包含object(属性为NSProgress)的代码块，该代码块也就是最终执行网络请求方法中progress:(void (^)(NSProgress * _Nonnull))uploadProgress位置的block代码块。此处代码块中可根据NSProgress的状态做用户自定义的行为，比如需要更新UI进度条的状态之类等等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (void) observeValueForKeyPath: (NSString *) keyPath ofobject: (id)object change: (NSDictionary‹NSString *id&gt;</span><br><span class="line">*)change context: (void *)context &#123;</span><br><span class="line">	if ([object isKindOfClass: [NSURLSessionTask class]] | | [object isKindOfClass: [NSURLSessionDownloadTask</span><br><span class="line">class]])&#123;</span><br><span class="line">		//给进度条赋新值</span><br><span class="line">		if ([keyPath isEqualToString:NSStringFromSelector (@selector (countofBytesReceived))]) &#123;</span><br><span class="line">			self.downloadProgress.completedUnitCount= [change [NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">		&#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector (count0fBytesExpectedToReceive) )])</span><br><span class="line">			self.downloadProgress. totalUnitCount = [change [NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">		] else if ([keyPath isEqualToString:NSStringFromSelector@selector(count0fBytesSent))]) &#123;</span><br><span class="line">			self.u@oadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">		] else if ([keyPath isEqualToString:NSStringFromSelector (Cselector(countofBytesExpectedToSend))]) &#123;</span><br><span class="line">			self.uploadProgress. totalUnitCount = [change [NSKeyValueChangeNewKey] longLongValue];</span><br><span class="line">		&#125;</span><br><span class="line">	//上面的赋新值会触发这两个，调用b1ock回调，用户拿到进度</span><br><span class="line">	//根据NSProgress的状态做用户自定义的行为，比如需要更新UI进度条的状态之类的</span><br><span class="line">	else if ([object isEqual: self.downloadProgress]) &#123;</span><br><span class="line">		if (self.downloadProgressBlock) &#123;</span><br><span class="line">			self.downloadProgressBlock(object);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (Lobject isEqual:self .uploadProgress]) &#123;</span><br><span class="line">		if (self.uploadProgressBlock) &#123;</span><br><span class="line">			self.uploadProgressBlock(object) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>监听上传、下载progress属性的KVO处理方法实现<br>以上就是AFN的请求过程进度更新返回的内部实现</p>
<hr>
<p>这里为什么要在AFN内部添加delegate，并将其和task进行一一绑定？<br> 在上面的更新进度状态时操作，完全可以放到AFURLSessionManager核心类本身中进行执行，但这样全部放在同一类下处理会不断增加核心类的复杂度。因此将请求过程与完成，交给delegate去处理，提高可维护性。</p>
<hr>
<p>当task任务执行resume方法开始请求网络后，会执行NSURLSession相关的代理方法。<br> 当收到返回数据时，会执行- (void)URLSession:(__unused NSURLSession *)session dataTask:(__unused NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data代理方法。该代理方法可能会在收到数据时多次执行，因此需要拼接其中的data数据。<br> 当task任务完成之后，不管请求成功还是失败，都会执行- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error代理方法，而此处返回的error并不是服务端的error，而是客户端本身的error，例如网络不可用、访问地址不可达等等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">              task:(NSURLSessionTask *)task</span><br><span class="line">didCompleteWithError:(NSError *)error</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    // delegate may be nil when completing a task in the background</span><br><span class="line">    // AFN作者说，task若在后台完成，可能delegate会为nil</span><br><span class="line">    if (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line"></span><br><span class="line">        // task结束，就移除对应的delegate</span><br><span class="line">        [self removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line">    //自定义Block回调</span><br><span class="line">    if (self.taskDidComplete) &#123;</span><br><span class="line">        self.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下delegate在task完成时[delegate URLSession:session task:task didCompleteWithError:error]做了什么操作。<br> 这时里面代码非常多，但是目的很简单，就是将网络请求相关的所有数据添加至名为userInfo字典中，并最终通过AFURLSessionTaskCompletionHandler代码块返回出去。<br> 打印下userInfo，可以发现字典中存储的key值以及意义：</p>
<ol>
<li>AFNetworkingTaskDidCompleteResponseDataKey session 存储task获取到的原始response数据，与序列化后的response有所不同</li>
<li>AFNetworkingTaskDidCompleteSerializedResponseKey 存储经过序列化（serialized）后的response</li>
<li>AFNetworkingTaskDidCompleteResponseSerializerKey保存序列化response的序列化器(serializer)</li>
<li>AFNetworkingTaskDidCompleteAssetPathKey 存储下载任务后，数据文件存放在磁盘上的位置。若downloadFileURL存在，则保存downloadFileURL地址；若不存在，则取出self.mutableData中的data数据保存。</li>
<li>AFNetworkingTaskDidCompleteErrorKey 错误信息</li>
</ol>
<p>当userInfo字典全部保存完成后，首先判断是否存在error。若存在error则说明task任务出错，需要处理并返回出error信息。此处运用到了GCD中dispatch_group调度组（通常在项目中需要指定多个任务全部完成后再执行其它任务时，使用dispatch_group调度组可以最快捷的实现该功能)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async (manager .completionGroup ?: url_session_manager_completion_group(),</span><br><span class="line">manager. completionQueue ?: dispatch_get_main_queue(),</span><br><span class="line">^ &#123;</span><br><span class="line">	if (self.completionHandler) &#123;</span><br><span class="line">		self.completionHandler (task.response, responseObject, error);</span><br><span class="line">	&#125;</span><br><span class="line">	//主线程中发送完成通知</span><br><span class="line">	dispatch_async(dispatch_get_main_queue(),^ &#123;</span><br><span class="line">		[[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskpidCompleteNotification</span><br><span class="line">object: task userInfo:userInfo];</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>dispatch_group调度组的使用</p>
<p>利用三位运算符，判断如果没有实现自定义的completionGroup和completionQueue，那么就使用AFNetworking提供的私有的dispatch_group_t和dispatch_get_main_queue线程。在调度组中执行AFURLSessionTaskCompletionHandler代码块并将task.response, responseObject和error返回出去。<br> 当前不存在error时，也就是task任务成功执行，会首先创建一个并发队列，用于在网络请求任务完成后处理数据的，并发队列实现多线程处理多个请求完成后的数据处理，并对数据进行一次序列化操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSError *serializationError = nil;</span><br><span class="line">responseObject = [manager.responseSerializer responseobjectForResponse:task.response data:data</span><br><span class="line">error:&amp;serializationError];</span><br></pre></td></tr></table></figure>
<p>根据对应的task和data将response data解析成可用的数据格式，比如JSON serializer就将data解析成JSON格式。序列化完成之后与error存在时数据处理逻辑相同，最终通过执行AFURLSessionTaskCompletionHandler代码块，根据代码块中的数据，返回至外层方法，判断执行失败block还是成功block。<br> 从AFN框架中，可以发现AFURLSessionManagerTaskDelegate与NSURLSessionTask都是通过AFURLSessionManager来进行生成、绑定、销毁等管理操作的<br>以上就是AFN的核心类AFURLSessionManager在网络请求之前、请求中、以及请求结束时，做的事情</p>
<hr>
<hr>
<p>后续讲AFURLRequestSerialization与响应AFURLResponseSerialization的序列化</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B6%88%E6%81%AF/" rel="tag">消息</a></li></ul>
    </div>

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-本地资源包下载更新机制" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/09/14/%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90%E5%8C%85%E4%B8%8B%E8%BD%BD%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/" class="article-date">
      <time datetime="2022-09-14T04:11:12.000Z" itemprop="datePublished">2022-09-14</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/09/14/%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90%E5%8C%85%E4%B8%8B%E8%BD%BD%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/">本地资源包下载更新机制</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>日常开发中遇到需要从服务器下载资源包,解压, 读取资源包的情况, 这种情况客户端需要做一些处理, 保证客户端使用的资源包是服务器的, 且未被篡改过的, 下载过程中断了怎么处理等一系列机制, 图片中展示整个验证过程</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8F%92%E4%BB%B6%E9%AA%8C%E8%AF%81/" rel="tag">插件验证</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B5%84%E6%BA%90%E4%B8%8B%E8%BD%BD/" rel="tag">资源下载</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a   href="/2022/09/14/%E6%9C%AC%E5%9C%B0%E8%B5%84%E6%BA%90%E5%8C%85%E4%B8%8B%E8%BD%BD%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/#more">查看更多 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-项目组件化添加模块" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/08/15/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E5%8C%96%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/" class="article-date">
      <time datetime="2022-08-15T14:12:22.000Z" itemprop="datePublished">2022-08-15</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/08/15/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E5%8C%96%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/">项目组件化添加模块</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>本人项目组件化添加模块的步骤, 记录一下, 方便后续维护</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/" rel="tag">组件化</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a   href="/2022/08/15/%E9%A1%B9%E7%9B%AE%E7%BB%84%E4%BB%B6%E5%8C%96%E6%B7%BB%E5%8A%A0%E6%A8%A1%E5%9D%97/#more">查看更多 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-LaunchScreen" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/08/11/LaunchScreen/" class="article-date">
      <time datetime="2022-08-11T00:22:12.000Z" itemprop="datePublished">2022-08-11</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/08/11/LaunchScreen/">LaunchScreen</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>LaunchScreen的坑</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B8%A9%E5%9D%91%E6%97%A5%E5%B8%B8/" rel="tag">踩坑日常</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a   href="/2022/08/11/LaunchScreen/#more">查看更多 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-Https四次握手" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/07/08/Https%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/" class="article-date">
      <time datetime="2022-07-08T10:55:11.000Z" itemprop="datePublished">2022-07-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/07/08/Https%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/">Https四次握手</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>Https四次握手</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Https/" rel="tag">Https</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E8%AE%AE/" rel="tag">协议</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a   href="/2022/07/08/Https%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/#more">查看更多 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
    <article id="post-NSURLComponents" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a  href="/2022/07/08/NSURLComponents/" class="article-date">
      <time datetime="2022-07-08T10:55:11.000Z" itemprop="datePublished">2022-07-08</time>
</a>

    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a  class="article-title" href="/2022/07/08/NSURLComponents/">NSURLComponents</a>
    </h1>
  


      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
              <p>NSURLComponents小记</p>
          
      
    </div>
    
    <div class="article-info article-info-index">
      
      
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
    </div>


      
    <div class="article-tag tagcloud">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/" rel="tag">知识点</a></li></ul>
    </div>

      
        <p class="article-more-link">
          <a   href="/2022/07/08/NSURLComponents/#more">查看更多 >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>











  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  

</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2024 Haven
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank">Hexo &nbsp;&nbsp;</a><a href="https://github.com/maochunguang" target="_blank">Blog</a> by tommy
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >极客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>


    <script>
        $(document).ready(function() {
            var backgroundnum = 1;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>






<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(
            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>